{"meta":{"title":"南院大王","subtitle":"十年饮冰，难凉热血。","description":null,"author":"Shawn Peng","url":"http://itnote.tech","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T05:13:19.000Z","updated":"2019-08-06T05:14:11.852Z","comments":false,"path":"categories/index.html","permalink":"http://itnote.tech/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-06T05:12:05.000Z","updated":"2019-08-06T05:13:08.447Z","comments":false,"path":"tags/index.html","permalink":"http://itnote.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"刷票作弊脚本","slug":"刷票作弊脚本","date":"2019-11-08T04:32:00.000Z","updated":"2019-11-08T05:34:33.459Z","comments":true,"path":"2019/11/08/刷票作弊脚本/","link":"","permalink":"http://itnote.tech/2019/11/08/刷票作弊脚本/","excerpt":"","text":"问题与分析问题最近有个朋友问我能不能帮我写个脚本投投票啊，我看今天有人一下子多了4万的投票，这肯定是作弊啊，你能不能帮帮我？我就很好奇这到底是咋回事。 分析于是我打开他给我的链接一看，非常简单的投票系统，就是发一个个的Get请求就可以了。 我看也挺简单，那我就直接写个python脚本去轮询跑就完事儿了，不过我也很谨慎，先用Postman做了最简单的测试，手动发了很多Get request，但是不一会儿问题来了。 完蛋，得意太早，ip明显是被封了，需要让我输入验证码，此时我陷入了沉思。目前有两个问题需要解决： 如果需要输入验证码，我该如何去解析呢？ 为何IP会被封呢？ 针对第一个问题，我首先想到的是拿到验证码的图片，然后通过开源软件库将验证码解析出来，然而万万没想到的是，这个验证是通过页面点击控件，JS代码触发Get请求生成的。这就让我很头疼了，因为意味着我很难拿到图片，即使可以，那也要通过UI的自动化框架去获取，通过点击控件，然后解析页面元素，很麻烦，而且稳定性不高。 我又陷入了沉思。不过既然单个IP会被封，那么我通过代理IP去投票呢？遇到验证码就换IP，这样是不是就可以规避这个问题了？不错，这是一个很好的解决办法。有了具体的方案之后，我开始代码的实施。 实现获取IP资源去网上花了5块钱买了两个IP资源，有效期一天，通过其API接口可以拿到有效的IP和端口号。 下面是返回的服务器的IP和端口： 123456789101112&#123; \"code\":200, \"success\":true, \"data\":[ &#123; \"ip\":\"115.213.103.48\", \"port\":3000, \"during\":2 &#125; ], \"msg\":\"操作成功\"&#125; Coding每次请求，获取IP资源也是新的，所以我只要在投票有问题之后，更换IP即可, 只要拿到的结果是成功的，就把IP和端口号解析出来。如果中间出现了什么Exception,那就休息一会，重新更换IP，主要是IP服务商的响应不及时，会有一些错误信息。 1234567891011121314def getHttpServer(self, url): res = requests.get(url, timeout=4) res.encoding = 'gb2312' try: rep_dict = json.loads(res.content.decode()) if rep_dict['success'] and rep_dict['code'] == 200: ip = rep_dict['data'][0]['ip'] port = rep_dict['data'][0]['port'] return f\"&#123;ip&#125;:&#123;port&#125;\" return None except: print(\"换IP，休息5秒\") time.sleep(5) 下面的代码中我隐去了API信息，但是不影响逻辑。主要的逻辑是通过代理IP不断地去发送请求，将票数和排名打印出来，如果排名到了第三名，那么投票的票数就够了， 1234567891011121314151617181920212223242526def vote(self, url_get_ip): url = 'vote request url' s = requests.Session() ip_port = self.getHttpServer(url_get_ip) if ip_port: while True: try: time.sleep(2) proxies = &#123; \"http\": \"http://&#123;&#125;\".format(ip_port), \"https\": \"https://&#123;&#125;\".format(ip_port) &#125; res = s.get(url, headers=self.headers, proxies=proxies, timeout=10) res.encoding = 'gb2312' rep_dict = json.loads(res.content.decode()) print(f\"票数:&#123;rep_dict['data']['count']&#125; ===&gt; 排名: &#123;rep_dict['data']['rank']&#125;\") if rep_dict['data']['rank'] == 3: self.not_enough = False break if rep_dict['data']['msg'] == 'need_captcha': print('验证码校验，准备换IP') return False except: print('投票有点小问题，pass') return False else: return False 到目前为止，已经刷到了前5名，因为刷得太快，现在已经停止了，虽然里面好多人也这么做，心知肚明，但是还是不要相互拆穿好了。这篇文章的目的不是说做什么偏门作弊的东西，只是个人的一种尝试，我觉很有意思，就记下来了。 源码仅供学习和参考：https://github.com/SouthernYard/vote","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"最近的一些想法","slug":"最近的想法","date":"2019-11-01T14:58:00.000Z","updated":"2019-11-01T15:30:16.591Z","comments":true,"path":"2019/11/01/最近的想法/","link":"","permalink":"http://itnote.tech/2019/11/01/最近的想法/","excerpt":"","text":"Part1最近一年来进行过一些尝试，比如试图转行机器学习，但是当我真正系统学完之后发现这并不是我喜欢的领域，或者说不适合太学术的东西。 大概一年前我开始学习机器学习，基本流程如下：1. 学习CS229及理论总结-学完2. 《统计学习方法》- 基本学完3. 《机器学习》- 翻阅4. 《机器学习实用指南》- 学完5. 《深度学习入门》- 学完6. 小象学院：《Python与机器学习》- 学完7. 深度之眼：比赛实战班 - 半途而废 在完成上面的第6项的时候，我已经对机器学习没有好奇心了。为什么呢？因为发现很多的模型都是已经集成成模块，如果要用，就去调用就可以了。当前完成一个机器学习模型的主要流程是什么呢？1. 特征工程2. 模型选择3. 评估4. 调参5. 完成 其中1是最困难的，花费时间最多，同时3~4是需要反复调试与测试的。可能我的眼界不高，目前能看到的就是这些，或许在未来，我会写一个机器学习的入门系列文章，暂时加入todo list吧。 Part2有一个想法，在脑海里存在很多年了，大概在2015年的时候便有了想法，可惜自己懂的不多，但是幸运的是，从去年开始一直零零碎碎地实现，目前已经完成不少了。当然离真正完成还有一些距离，不过我也愿意为之努力。具体是什么，暂时不说了，等我完成那一天，我在跟全世界正式宣布吧。不管成功与否，尝试终究是需要的。 Trials and errors. 从0到1，真是令人兴奋。 Part3主要是展望： 机器学习的东西既然学了，那么还是要用的，在未来的规划中可能并不是自己的重点。 Java还是自己主要的方向。 为自己铺路","categories":[{"name":"随笔","slug":"随笔","permalink":"http://itnote.tech/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://itnote.tech/tags/随笔/"}],"author":"Shawn Peng"},{"title":"爬取全国所有手机号码","slug":"爬取上海市的所有电话号码","date":"2019-11-01T12:10:00.000Z","updated":"2019-11-01T15:31:36.164Z","comments":true,"path":"2019/11/01/爬取上海市的所有电话号码/","link":"","permalink":"http://itnote.tech/2019/11/01/爬取上海市的所有电话号码/","excerpt":"","text":"背景之前支付宝可以分享红包，当收到红包的人点开你分享的支付宝口令之后，这个人就会有相应的红包额度。如果这个人在设定的时间内可以用掉这个额度，那你也相应会获得相同的红包数量。当时有人也因此发了笔大财，怎么做的呢？有人会通过群发大量的短信，当很多人收到短信然后会点进支付宝app，然后自己也会有相应的收益。 当然这篇文章的主题不是为了如何赚钱，而是我在思考类似的问题时，想到如何能获取大量的手机号码呢？爬虫一般会遇到信息安全问题，很多涉及个人隐私，所以这里的代码仅供参考。 解决方案 首先我找到了一个网站，手机全能查，按照这里的分类，应该是包含了全中国所有人的手机号码。作为示范，我先尝试爬取的是上海下面的所有手机号码。 根据上面三张图可以看到，三大运营商的上海地区号码都可以在这个链接下面找到. 我随便点击某个号码段，审查网页元素。 可以看到这是一个静态网页，所以解决方案有了： 获取不同号码段 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 将号码存在文件中 OK，下面开始coding。 代码实现对于爬虫来讲，Python是很好的工具，requests和BeautifulSoup都是Python爬虫中很实用的模块。代码也是按前面所述的步骤实现的。 获取不同号码段： 通过这个类去获取所有的号码段： 12345678910111213141516171819202122class GetPhoneSegment(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; self.url = 'http://so.qqdna.com/city/shanghai/shanghai.php' def get_seg_num(self): res = requests.get(self.url) res.encoding = 'gb2312' bs = BeautifulSoup(res.text, 'lxml') all_seg = bs.findAll('li') return self.filter_data(all_seg) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9]+') list_string_data = rr.findall(str(original_data)) data_remove_dup = list(set(list_string_data)) data_remove_dup.sort(key=list_string_data.index) return data_remove_dup 获取号码段的目的是为了拼装不同号码段所对应的URL。 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 通过这个类获取不同的号码段下的所有号码，通过正则表达式解析所有的号码，最后将文件保存到硬盘上。 1234567891011121314151617181920212223class GetPhoneNumber(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; def get_phone_num(self, seg_phone_num): url = 'http://so.qqdna.com/mobile/shanghai_' + seg_phone_num + '.html' res = requests.get(url) res.encoding = 'gb2312' bf = BeautifulSoup(res.text, 'lxml') return str(self.filter_data(bf.body.table.tr.td)) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9][0-9]&#123;9&#125;') list_string_data = str(rr.findall(str(original_data))[2:]) filtered_data = list_string_data.replace(r'[', '') filtered_data = filtered_data.replace(r']', '') filtered_data = filtered_data.replace(r\"', '\", '\\n') filtered_data = filtered_data.replace(r\"'\", '') return filtered_data 将号码存在文件中在下面的主函数中可以看到,将获取到的手机号码存储在txt文本中。1234567891011if __name__ == '__main__': get_phone_seg = GetPhoneSegment() seg_num_list = get_phone_seg.get_seg_num() get_num = GetPhoneNumber() print(\"号码段数量：\" + str(len(seg_num_list))) for seg_num in seg_num_list: data = get_num.get_phone_num(seg_num) fo = open(seg_num + '.txt', 'w') # a: 追加， w: 覆盖 fo.write(data) fo.close() 跑起来!为了验证代码可以正常运行, 直接运行看是否能够下载号码。由于是公司的电脑, 隐去了一些个人信息。 由下图可以看到, 上海市所有的号码段有5880个, 基本上一个号码段是9999个, 按照1万个计算, 上海市的号码数量是5880万个左右, 还是有点多的。 运行中 运行一段时间后, 可以看到文本文件中已经有不少号码了。当然我并没有把将近六千万的号码全部下载完……电脑吃不消,我也不需要这么多。当然为了避免总是在一个号码段下载号码, 可以加入随机函数, 比如说在一个号码段中取10个, 这样也有将近6万个号码，看个人需求。 号码 这个是完整代码：https://github.com/SouthernYard/GetNumber","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"对作弊行为的视频进行数据标注","slug":"对作弊行为的视频进行数据标注","date":"2019-08-26T04:40:00.000Z","updated":"2019-11-01T12:08:20.799Z","comments":true,"path":"2019/08/26/对作弊行为的视频进行数据标注/","link":"","permalink":"http://itnote.tech/2019/08/26/对作弊行为的视频进行数据标注/","excerpt":"","text":"背景最近在参加一个作弊行为分析的比赛，数据集是由比赛方提供的，也是被标注的。对于数据标注，我也进行了一些尝试。 赛题我们最终目标是从真实考场视频录像中检测出谁在什么时候作弊，以及作弊的类型，如看手机，扔纸团等。现阶段我们通过员工录制模拟作弊视频，视频有十段，每段比较类似，都是考场固定30个座位，有二，三十人按照以下顺序作弊：作弊类型：（视频也是根据这个顺序录制的，扔是单人行动，传是两人手与手之间的传动）1.拿出包放到桌上，2.低头拿出手机等偷看3.扔纸团到前桌桌上4.扔纸团给后桌桌上，5.扔纸团给左边桌上6.扔纸团给右边桌上7.传纸条给前桌8.传纸条给后桌9.传纸条给左桌10.传纸条给右桌11.扔纸团到前桌地上12.扔纸团到后桌地上13.扔纸团到左桌地上14.扔纸团到右桌地上15.捡纸团 （捡纸团可能出现在前面行动中，因为可能纸团掉在地上都会去捡）16.打开纸团 （打开纸团前面行动也会有，不管是扔纸团还是传）带试卷出场 数据标注对于视频数据的标注的要求是需要找出各种作弊行为对应的所在帧数。第一行是关注区域四个点坐标，这个区域不能太大，以至于其他同学干扰，不能太小，以至于关注的人动作被剪裁。第二行开始每一个作弊行为一行，每一行起始帧，结束帧，作弊类型。下图就是示例： 数据示例 对于视频数据的标注，就需要用到OpenCV了，初步的想法是： 将指定个某个人的位置框出来 实时显示帧率 不过这也有个小问题，人的动作行为太快，帧率也很快，人工标注是有误差的。尽管如此，我还是对几个样本数据进行了标注，代码实现如下： 12345678910111213141516171819202122import cv2cap = cv2.VideoCapture('./7.mp4')frame_count = 0while cap.isOpened(): ret, frame = cap.read() if ret == True: frame = frame[100:250,950:1100] font = cv2.FONT_HERSHEY_SIMPLEX frame_count = frame_count + 1 cv2.putText(frame, str(frame_count),(0,30), font, 0.5,(255,255,255),2,cv2.LINE_AA) cv2.imshow('frame',frame) c = cv2.waitKey(1) if cv2.waitKey(1) &amp; 0xFF == ord(' '): cv2.waitKey(0) elif c == 27: break else: breakcap.release()cv2.destroyAllWindows() 左上角的白色数据就是帧数，这里的视频就是规定显示的视频区域，由此可以根据要求标注数据。 区域视频","categories":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/categories/数据标注/"}],"tags":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/tags/数据标注/"},{"name":"视频","slug":"视频","permalink":"http://itnote.tech/tags/视频/"},{"name":"机器学习","slug":"机器学习","permalink":"http://itnote.tech/tags/机器学习/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://itnote.tech/tags/OpenCV/"}],"author":"Shawn Peng"},{"title":"[LeetCode]2. 两数相加","slug":"LeetCode-两数相加","date":"2019-08-16T10:11:00.000Z","updated":"2019-08-19T14:05:24.629Z","comments":true,"path":"2019/08/16/LeetCode-两数相加/","link":"","permalink":"http://itnote.tech/2019/08/16/LeetCode-两数相加/","excerpt":"","text":"描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析两数相加，顾名思义这是要解决两个数字相加问题, 而入参是两个链表. 那我们需要思考下面几个问题: 1. 如何按位相加? 观察链表，其第一个节点实际代表的是个位，第二个代表的是十位，依次是百位，千位……所以从第一个节点按位置相加就可以了。 2. 怎么解决进位? 两个0-9的自然数相加的值，最大的和是18，因此，进位只有0或者1，在两数相同位置上加上进位即可，即便加上进位最大也只有19，没到20。因此需要有个变量处理进位问题即可。 3. 链表结束/开始是null, 怎么处理? 对于null值的处理其实很简单，只要认为这是一个值为0的节点即可。如果都是null，那就不用再计算了。 4. 两个链表的长度不一样, 怎么处理? 链表长度不一样意味着是长度不同的数字，那么较短的链表比较长链表短的地方，都认为值为0的节点即可。 5. 进位之后, 两个链表指向的下一个节点是null, 怎么解决? 这算是一个较为边缘的场景，比如[2]+[9], 这个时候高位没有数字，然而进位为1。只要为这个特殊情况再加一个特殊处理即可。 代码步骤： 先定义了计算结果的链表头，链表当前节点和进位变量。 当l1或l2其中之一不为null的时候，进行相加计算。 如果链表（l1,l2）不为null，则取值，反之则取0,因为节点已经用不到，直接移动节点位置。 两个值相加，并加上进位。 计算出进位和当前位的数值。 完成计算，移动计算结果的当前节点。 处理分析章节中的第五个问题，当l1和l2都为null的时候，处理进位问题，有进位，则结果节点再新增一个节点。 返回节点头后面的链表结果，即是题目的解。 两数相加 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //需要一个header和一个pointer ListNode pointer = new ListNode(0), header = pointer; //进位 int carry = 0; //链表其中之一不能为null while((l1 != null || l2 != null)) &#123; //链表为null,返回值就应该为0， 方便相加 int val1 = (l1 != null) ? l1.val : 0; //移动链表节点 if(l1 != null) l1 = l1.next; int val2 = (l2 != null) ? l2.val : 0; if(l2 != null) l2 = l2.next; //上下相加，并且加上进位值 int sum = val1 + val2 + carry; //计算进位，满10进1 carry = sum / 10; //除10的余数就是当前位的值 ListNode currentNode = new ListNode(sum % 10); //结果链表当前节点赋值 pointer.next = currentNode; //移动当前节点 pointer = pointer.next; &#125; if (carry &gt; 0) &#123; // 特殊处理，如果l1与l2都是null的时候：1. l1和l2传进相加方法的时候的时候即是null // 2. 计算到最高位或者，最高位相加满10 pointer.next = new ListNode(carry); &#125; return header.next; &#125;&#125; 拓展 现在的问题是解决两个数相加的问题，那如果是三个数呢？其实从这道题拓展开去也不难，先处理其中两个链表相加的和，在将和的结果和第三个链表相加即可，有点麻烦，也不失为一个办法。 方法传入多参数列表进行处理，此处就不展开了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"如何在云服务器上搭建Hexo博客","slug":"在云服务器上搭建Hexo博客","date":"2019-08-10T08:49:00.000Z","updated":"2019-08-16T12:56:49.863Z","comments":true,"path":"2019/08/10/在云服务器上搭建Hexo博客/","link":"","permalink":"http://itnote.tech/2019/08/10/在云服务器上搭建Hexo博客/","excerpt":"","text":"前言最近搭建一个自己的博客，历时一个星期的空余时间。搭建博客的主要目的是想记录自己的技术笔记和心得，方便与人分享和自己查阅。很久以前我就有搭建博客的想法，但是没有实践，一个是懒，一个是没有找到合适的博客系统。后来发现Hexo这个博客系统，感觉不错，但是看了一些教程，感觉搭建起来很麻烦，我就又放弃了，最近在朋友的鼓励下，终于把想法实践了。 在搭建博客之前，我对比了自己知道两个博客系统，WordPress和Hexo。 WordPress: 优点 缺点 容易搭建，上手快 臃肿不轻便 主题多 需要提供服务器和域名 插件多 Hexo: 优点 缺点 轻便：全是静态文件 只能在本地电脑工作 简洁：天然支持MarkDown 维护不便 免费：GitHub 先前搭建过WordPress, 我并不是很喜欢WordPress的主题风格，个人认为不太适合写技术博客，找了些主题后，没有发现自己喜欢的。看到一些技术大佬很多在用Hexo的博客，并且对比了优缺点，最终决定搭建基于Hexo的博客。根据Hexo的缺点，我萌生了一个想法：能不能将Hexo搭建在云服务上？找了相关资料，确实有人这么做。本片博客主要解决了以下几个问题。 在云服务器上搭建Hexo博客系统 在线编辑和发布博客 配置Https 博客搭建服务器和域名服务器是在阿里云上买的最低配置的香港服务器，因为香港服务器不需要备案就能直接访问，同时速度也不会太差。同时域名也是在阿里云上购买的。 服务器版本CentOS 7.4 Hexo搭建Hexo的搭建过程网上有太多，没必要重复造轮子，没搭建过的朋友可以参考这篇博文。 我的博客用的主题是Indigo,其中不少问题都可以在WiKi中找到。 配置Hexo在搭建完成之后，服务器的运行需要依赖于hexo-server和hexo-admin。如果已经安装，可以跳过此步骤。 cd到博客根目录下，执行： 12npm install hexo-server@0.3.1 --savenpm install hexo-admin@2.3.0 --save 安装完毕之后，执行 1hexo s 打开浏览器，访问http://yourServerIP:4000, 即可预览，访问http://yourServerIP:4000/admin, 即可进入hexo-admin后台管理界面。 hexo-admin默认是没有密码保护，需要自己手动开启。在进入后台管理页面时，点击Settings--Setup authentification here设置后台管理密码。 Setting 输入用户名密码之后，将生成的代码复制。 Admin Config Section 然后打开博客根目录下的_config.yml，将复制的代码粘贴到末尾。重启hexo服务器，进入http://yourServerIP:4000/admin, 如果出现登录界面，则设置成功。 后台运行因为shell关掉或者使用ctrl+c关闭，则会导致服务器结束进程。所以我写了个JS脚本，执行之后，后台会一直运行hexo服务器。安装pm2 1npm install -g pm2 在博客根目录下创建一个hexo_run.js。 123456789const &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 在根目录下运行 1pm2 start hexo_run.js 这样hexo服务器就能一直在后台运行不会被杀死。 Hexo部署每次都用通过指令来部署，那是相当难受的。不过hexo-admin提供了一键部署功能： Deploy 通过点击Deploy按钮就能执行你的部署脚本。在博客根目录下添加配置： 12admin: deployCommand: &apos;./hexo-deploy.sh&apos; 并且在根目录下创建hexo-deploy.sh，并编辑： 12#!/usr/bin/env shhexo g 给hexo-deploy.sh授予权限： 1chmod a+x hexo-deploy.sh 重启服务器之后，编辑博文后点击Deploy按钮就能将文章渲染成html页面访问了。 与Github Page同步GitHub的配置可以参考前文中所提到的博客搭建文章，里面有详细的配置过程。如果需要与Github page同步，则修改hexo-deploy.sh就可以了。修改如下： 12#!/usr/bin/env shhexo g -d 然后重启服务器，点击Deploy按钮即可，之后的改动都会同步到Github上。 服务器配置DNS解析配置进入域名的DNS解析中，按如下配置即可： DNS解析 然后访问你的域名，查看是否能访问到博客页面。 配置Https关于Https的配置，可以参考这篇博文。需要在阿里云购买云盾证书，并添加解析。在下载完证书之后需要在nginx.conf中配置文件。 12345678910111213141516171819202122server &#123; listen 80; server_name www.itnote.tech; return 301 https://www.itnote.tech$request_uri; &#125;server &#123; listen 443 ssl; server_name www.itnote.tech; ssl on; ssl_certificate /usr/local/nginx/cert/pem_file.pem; #证书地址 ssl_certificate_key /usr/local/nginx/cert/key_file.key; #证书地址 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://localhost:4000/; &#125; 保存后重启nginx服务 1service nginx restart 看上图中有锁状的地址即配置成功。 Https Cert","categories":[{"name":"博客","slug":"博客","permalink":"http://itnote.tech/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://itnote.tech/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://itnote.tech/tags/Hexo/"},{"name":"Https","slug":"Https","permalink":"http://itnote.tech/tags/Https/"},{"name":"WordPress","slug":"WordPress","permalink":"http://itnote.tech/tags/WordPress/"}],"author":"Shawn Peng"}]}