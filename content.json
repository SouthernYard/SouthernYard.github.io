{"meta":{"title":"南院大王","subtitle":"十年饮冰，难凉热血。","description":null,"author":"Shawn Peng","url":"http://itnote.tech","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T05:13:19.000Z","updated":"2019-08-06T05:14:11.852Z","comments":false,"path":"categories/index.html","permalink":"http://itnote.tech/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-06T05:12:05.000Z","updated":"2019-08-06T05:13:08.447Z","comments":false,"path":"tags/index.html","permalink":"http://itnote.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何在cucumber UI case中录制视频","slug":"如何在cucumber-UI-case中录制视频","date":"2020-09-21T03:34:00.000Z","updated":"2020-09-29T12:56:08.268Z","comments":true,"path":"2020/09/21/如何在cucumber-UI-case中录制视频/","link":"","permalink":"http://itnote.tech/2020/09/21/如何在cucumber-UI-case中录制视频/","excerpt":"","text":"背景在工作中会写一些UI自动化测试的case来测试, 但是UI测试的时候, case会失败, 此时如果有个截图或者录屏就很有用. 由于在工作中使用的是cucumber, 所以代码是在cucumber中实现的, 但是作为工具, 也可以独立使用. 方案在UI case中, 如果给失败的case进行录屏, 那么可以更加有效, 有针对性地对case的失败行为进行分析. 能清除地知道,在执行某些步骤的时候, 失败了. 因此方案如下: 对每一个case进行录屏 将失败的case的录屏嵌入到cucumber的报告中. 展示失败case的视频, 分析问题. 代码在此我使用的是monte-screen-recorder这个工具, 因为此工具的录屏是avi, 无法直接将视频在html页面上渲染, 所以我使用ffmpeg的java工具包, 将avi转码成mp4.gradle的依赖是 123compile group: 'com.github.stephenc.monte', name: 'monte-screen-recorder', version: '0.7.7.0'compile group: 'net.masterthought', name: 'cucumber-reporting', version: '4.10.0'compile group: 'ws.schild', name: 'jave-all-deps', version: '3.0.1' 直接贴代码了… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class ScreenRecorderUtil extends ScreenRecorder &#123; private static ScreenRecorder screenRecorder; private String scenarioName; private static String videoName; private static final String RECORDING_PATH = \"./build/recording\"; public DPMScreenRecorderUtil(GraphicsConfiguration cfg, Rectangle captureArea, Format fileFormat, Format screenFormat, Format mouseFormat, Format audioFormat, File movieFolder, String scenarioName) throws IOException, AWTException &#123; super(cfg, captureArea, fileFormat, screenFormat, mouseFormat, audioFormat, movieFolder); this.scenarioName = scenarioName; &#125; @Override protected File createMovieFile(Format fileFormat) throws IOException &#123; if (!movieFolder.exists()) &#123; movieFolder.mkdirs(); &#125; else if (!movieFolder.isDirectory()) &#123; throw new IOException(\"\\\"\" + movieFolder + \"\\\" is not a directory.\"); &#125; SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH.mm.ss\"); videoName = scenarioName + \"-\" + dateFormat.format(new Date()) + \".\" + Registry.getInstance().getExtension(fileFormat); return new File(movieFolder, scenarioName + \"-\" + dateFormat.format(new Date()) + \".\" + Registry.getInstance().getExtension(fileFormat)); &#125; public static void startRecord(String scenario) throws Exception &#123; File file = new File(RECORDING_PATH); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); int width = screenSize.width; int height = screenSize.height; Rectangle captureSize = new Rectangle(0, 0, width, height); GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment(). getDefaultScreenDevice() .getDefaultConfiguration(); screenRecorder = new DPMScreenRecorderUtil(gc, captureSize, new Format(MediaTypeKey, FormatKeys.MediaType.FILE, MimeTypeKey, MIME_AVI), new Format(MediaTypeKey, FormatKeys.MediaType.VIDEO, EncodingKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, CompressorNameKey, ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, DepthKey, (int) 24, FrameRateKey, Rational.valueOf(15), QualityKey, 1.0f, KeyFrameIntervalKey, (int) (15 * 60)), new Format(MediaTypeKey, FormatKeys.MediaType.VIDEO, EncodingKey, \"black\", FrameRateKey, Rational.valueOf(30)), null, file, scenario); screenRecorder.start(); &#125; public static void stopRecord() throws Exception &#123; screenRecorder.stop(); &#125; public static byte[] getRecord() throws Exception &#123; return FileUtil.readAsByteArray(convertAviToMP4(new File(RECORDING_PATH + \"/\" + videoName))); &#125; private static File convertAviToMP4(File source) throws Exception &#123; File target = new File(RECORDING_PATH + \"/\" + \"target.mp4\"); AudioAttributes audio = new AudioAttributes(); audio.setCodec(\"libmp3lame\"); audio.setBitRate(64000); audio.setChannels(1); audio.setSamplingRate(22050); VideoAttributes video = new VideoAttributes(); video.setCodec(\"libx264\"); //编码设置 video.setBitRate(1920 * 1080); //比特率设置 video.setFrameRate(120); video.setPixelFormat(\"yuv420p\"); EncodingAttributes attrs = new EncodingAttributes(); attrs.setOutputFormat(\"mp4\"); attrs.setInputFormat(\"avi\"); attrs.setAudioAttributes(audio); attrs.setVideoAttributes(video); Encoder encoder = new Encoder(); MultimediaObject multimediaObject = new MultimediaObject(source); encoder.encode(multimediaObject, target, attrs); return target; &#125;&#125; cucumber的case中可以使用hook类, 将case的视频嵌入的报告中, 示例代码如下: 123456789101112131415161718public class CucumberHooks &#123; @Before(order = Integer.MAX_VALUE) public void startRecording(Scenario scenario) throws Exception &#123; if (Boolean.parseBoolean(System.getProperty(\"recordVideo\"))) &#123; // start recording ScreenRecorderUtil.startRecord(scenario.getName()); &#125; &#125; @After(order = Integer.MAX_VALUE) public void getRecording(Scenario scenario) throws Exception &#123; DPMScreenRecorderUtil.stopRecord(); if (scenario.isFailed()) &#123; scenario.embed(DPMScreenRecorderUtil.getRecord(), \"video/mp4\"); &#125; &#125;&#125;","categories":[],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/tags/技术分享/"}],"author":"Shawn Peng"},{"title":"宽界系统介绍","slug":"宽界系统介绍","date":"2020-07-27T12:41:00.000Z","updated":"2020-08-10T04:39:49.553Z","comments":true,"path":"2020/07/27/宽界系统介绍/","link":"","permalink":"http://itnote.tech/2020/07/27/宽界系统介绍/","excerpt":"","text":"宽界(QuantWorld)宽界系统（以下简称宽界）是一个基于Java的开源量化交易系统，系统的完成情况可以参考组件部分。宽界主要由Admin, Broker, CEP, OMS, Application和BackTestEngine等6个部分组成。目前只完成了系统的大部分基础框架，一些细节功能还在完善中。在量化交易领域，看到了很多基于Python的系统，却很少有基于Java实现的系统，所以这是我设计宽界的初衷。宽界目前只完成了数字货币的火币API的接入，后续会接入更多交易所的API，在框架的设计之初，股票期货等也是可以接入的，这也在未来的计划之中，非常欢迎有志的朋友一起合作，贡献代码。 宽界提供什么？ 注册、登录、个人账户。 数字火币，期货，股票交易API的高可扩展。 策略自定义开发。 交易状态邮件提醒功能。 账户盈亏可视化展示。 多交易所接入。 多策略执行，多标的监控。 策略交易日志展示。 多交易所，多账户资产显示 宽界架构 upload successful 技术栈：Vue/Bootstrap/jQuery/Thymeleaf/Spring Data Jpa/Spring Boot Mail/WebJars/Mysql/MongoDB/Tomcat/WebSocket 组件:Admin AdminEngine Broker: Gateway API Router CEP EventDispatcher SignalCalculator DataEngine DataBase OMS OMSEngine RiskManagement PositionManagement EventProcessor Application Monitor Commander Demo Strategy BackTestEngine BackTestEngine Matcher Analyzer 宽界如何部署/使用系统展示 主页 交易所展示: 可以展示用户当前添加的所有交易所信息 策略库: 展示所有添加的交易策略, 并且所有添加的策略都是可以针对多个标的 代理设置: 为系统添加代理服务器信息 upload successful 个人资产: 个人资产展示","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/tags/技术分享/"}],"author":"Shawn Peng"},{"title":"Linux下线程绑定CPU","slug":"Linux下CPU绑定线程","date":"2020-07-19T14:12:00.000Z","updated":"2020-07-19T15:06:10.123Z","comments":true,"path":"2020/07/19/Linux下CPU绑定线程/","link":"","permalink":"http://itnote.tech/2020/07/19/Linux下CPU绑定线程/","excerpt":"","text":"背景一般情况下，吞吐量和延迟之间是有成正比的，即吞吐量越大，任务的延迟也就越大，反之亦然。在许多的应用场景下，更希望的是吞吐量大，同时也希望保证低延迟的。如果是为了满足吞吐量，但是对延迟的要求并不是特别高，只需要保证最终一致性，则多线程即可保证。但是为了保证低延迟，则更希望JVM/MicroSerivce/Machine只专注一件事。实际上，单线程在专注一个任务时，效率是非常高的。为此，要保证整个系统的低延迟，单个CPU/CPU Core绑定一个JVM/MicroSerivce/Machine是一个非常好的解决方案。那如何解决呢？ 方案服务之间使用高速总线/队列通信，或者其他队列或者总线，具体有Kafka，RabbitMQ, RocketMQ等等。 Archtecture 每个服务都是单线程。OK，可能这个时候有人问了，那么在这种情况下，多个服务就类似于多线程了，跟原来单机的多线程岂不是没有区别？实际上这是个概念问题，即并行和并发的区别。简单讲一下并发和并行的区别。 并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。如：打游戏和听音乐两件事情在同一个时间段内都是在同一台电脑上完成了从开始到结束的动作。那么，就可以说听音乐和打游戏是并发的。 并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。 总结：可以看到，在一个时间点上，并发只做一个任务，并行在做多个任务。 并发是单CPU操作，牺牲线程的调度时间，完成一个多线程完成多任务的操作，主要牺牲时间。 并行是多CPU操作，系统CPU的数量，完成多个CPU完成多任务的操作，主要牺牲物理资源。 并行和并发 所以总结以上，在提高任务的处理效率，降低其延时的瓶颈都落到了高速总线上了，但这不是本节所讲的重点。回归重点，如何将一个线程绑定到一个CPU上，只专注做一件事情呢？我在GitHub上找到了一个开源库Java-Thread-Affinity,就能做到这件事。 代码在我仔细研读Java-Thread-Affinity的使用介绍后，其核心主要是两点： 在Linux环境下，隔离CPU，可参考：Get Started 使用上述代码库,可参考：Using AffinityLock 比如在我前文事件分发器（订阅/发布模式）的实现中提到的事件分发器，我在其中设计一个定时事件，但是又想保住其任务的准时，定时器事件不受队列排队影响导致过多的延时，这时，CPU隔离就显得格外重要，活不多说，coding please。 123456789101112131415timer = new Thread(() -&gt; &#123; AffinityLock al = AffinityLock.acquireLock(); try &#123; while (isActive) &#123; try &#123; TimeUnit.MILLISECONDS.sleep(interval); publishTimer(); &#125; catch (Exception e) &#123; logger.error(\"Failed to generate timer event\", e); &#125; &#125; &#125; finally &#123; al.release(); &#125;&#125;); 可以看到我使用AffinityLock.acquireLock()获取一个CPU锁，这样既可以完成对CPU的隔离，并实时分发事件。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://itnote.tech/tags/线程/"}],"author":"Shawn Peng"},{"title":"HTTP和WebSocket的代理设置","slug":"Java工程中的代理设置","date":"2020-06-13T14:45:00.000Z","updated":"2020-06-26T02:47:03.646Z","comments":true,"path":"2020/06/13/Java工程中的代理设置/","link":"","permalink":"http://itnote.tech/2020/06/13/Java工程中的代理设置/","excerpt":"","text":"背景最近在项目工程实施的过程中，需要使项目可以获取一些信息，于是想到如何通过代理获取。 问题点 如何能够使所有的web请求的时候都走代理呢？ 解决过程 能否让自己的所有软件都走代理？ -可行，只要软件可以设置代理。 如果1可行，是否可以让Intellij走代理？ -可行，但是无法让Web工程全部走代理。 既然2不可行，能否让JVM走代理。 -不知道，没找到方案。 那是否可以让HTTP请求走代理？ -可行，在创建RestTemplate对象的时候设置Proxy WebSocket是否可行？ -可行，在创建WebSocket的时候设置Proxy即可。 代码根据4,5点，可以在创建RestTemplate对象和WebSocketClient对象时候，设置代理即可。以下的MyRestApi继承了RestTemplate父类，在构造对象的时候设置了代理。本地代理使用的是SOCK5协议，所以在获取Proxy的时候，使用的是SOCKS。在Prxoy类中，默认情况下使用的是直连，即DIRECT，而此处用的是SOCKS，如果你的有设置HTTP代理，代码中使用HTTP应该也可以。 HTTP请求12345678public MyRestApi() &#123; SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); Proxy proxy = ProxyUtil.getProxy(); factory.setProxy(proxy); factory.setConnectTimeout(3000); factory.setReadTimeout(3000); super.setRequestFactory(factory);&#125; 1234567public class ProxyUtil &#123; @NotNull public static Proxy getProxy() &#123; return new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;127.0.0.1&quot;, 1234)); &#125;&#125;此处1234是SOCKS的代理端口。 WebSocket1234public MyWebSocketApiBase(String uri, BaseGateway gateway) throws URISyntaxException &#123; super(new URI(uri), new Draft_6455()); super.setProxy(ProxyUtil.getProxy());&#125;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"代理","slug":"代理","permalink":"http://itnote.tech/tags/代理/"}],"author":"Shawn Peng"},{"title":"对人生意义的思考","slug":"对人生意义的思考","date":"2020-05-19T13:37:00.000Z","updated":"2020-05-19T14:03:20.365Z","comments":true,"path":"2020/05/19/对人生意义的思考/","link":"","permalink":"http://itnote.tech/2020/05/19/对人生意义的思考/","excerpt":"","text":"一、意义 如果买票去游乐场玩一圈出来，在记忆中，甚至潜意识中都不会存在这段记忆，永远也不知道有过这段经历，那玩游乐场的意义是什么？意义在这里的定义是事物对自己的价值，比如精神或物质。那既然如此，这段经历对“我”是没有任何意义的，因为没有影响到“我”。 反之，如果这段经历的记忆是保留的，那很明显，这段经历对“我”是有意义的，因为影响到了“我”。 假设人的生命是无限，有各种各样的类2事件，那这些事件在对“我”的意义是一直存在的。 很明显人的生命是有限且短暂的，那也就是说类2事件的意义也是短暂的，随人生长短所存在。 既然人生的意义是短暂的，是依存于个体的存在，那人生的存亡宛如第1点所述，所以结论就是人生没有意义。 二、赋予 根据第一点结论，人生无意义。那既然如此，为什么要活着？娘胎里来，坟墓里去，生不带来，死不带去，何必要跟自己较劲，跟别人较劲？在复杂的社会规则中痛苦？即便世界首富，死后不也一抔灰？所以为什么要活着，直接结束生命也是一样。 怕死 道德/宗教/信仰约束 除2点外的自欺欺人 对于1.1，是对死亡恐惧，或者是对未知的恐惧，这是本能，也是人类能繁衍到现如今的先决条件。 对于1.2，道德的约束源于复杂社会关系，宗教的约束来源于对意义的重新定义。道德约束很好理解，而宗教/信仰的约束则是对死后的寄托，这是突破了“一”中的第四点。比如轮回，上天堂，有72个处女等。宗教又分为两种： 向死而生：为了死后更好的回报，则在现世做得更好。 向生而生：只注重现在现世的，比如自己的行为影响子孙后代。 对于1.3，所谓的自欺欺人，基本就是人生体验论，既然活一次，就要好好活，好好享受。不过这种想法却没有深刻思考人生的意义，或者也没有认真的面对，反而是一种轻浮的态度。怎么类比呢？类似“不在乎天长地久，只在乎曾经拥有。”依旧可悲和矛盾。 因此，为了能正常的存活下去，需要从客观的无意义的前提下，为自己赋予意义。意义的选择因人而异，在恐惧中生活，未免也太胆战心惊了，在道德/宗教/信仰中生活，未免显得媚俗/愚昧/自欺欺人，而体验论的拥趸，未免显得轻浮而轻视生命。三者都可为自己的人生赋予其意义。 三、选择思来想去，突破人生意义的死循环，只有赋予其意义。我既不想胆战心惊地生活在恐惧中，也不想在感官体验中迷失自我，轻视生命。选择道德，这未免显得太媚俗。道德观念是由社会关系所决定的，也就是说，是具有时代性的，且迎合大众的，这类似法律的界定。法律是道德底线，法律一直在变，不同的国家有不同的法律，因此道德观念是随时间空间而变化的。对此我特别喜欢引用道德经的第三十八章的内容：“上德不德，是以有德；下德不失德，是以无德。上德无为而无以为，上仁为之而无以为，上义为之而有以为，上礼为之而莫之应，则攘臂而扔之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄而乱之首。前识者，道之华而愚之始。是以大丈夫处其厚，不居其薄，处其实，不居其华。故去彼取此。”这里的德，则指的是现代意义的“道德”。所谓的道德，是失去“道”之后所产生的，而后面的仁义礼等都是虚浮的演变，如果核心的“道”都没有，后面的都是虚假。因此，只是以道德观念立世，显然缺少了根基。选择宗教，首先，宗教太多了，选择哪一个呢？因此宗教不具备普适性，很多东西说不清楚。宗教本身存在，或者说意义，是为了解决人本文所要讨论的问题，即保安三问：你是谁，从哪里来，到哪里去。不同宗教有不同解释。真要选择，随便选择一个便是，实际上是殊途同归的，倒不用纠结太多，也不必踩高捧低。我始终相信宗教是伟大的，一个是有一个途径可以让迷惑的人在其中思索一生，不至于使个体迷茫，惶惶终日；另一个是保证了社会一定的稳定。只不过宗教仍旧无法满足我的需求，因为宗教中总有很多对于三问探讨之外的东西，不纯粹。与其用机关枪去打靶，我更想一击中的。选择信仰，信仰≠宗教。很多宗教人士在布道的时候总问有什么信仰，这里特指宗教信仰。可以信仰祖先，信仰金钱，信仰某种思想，在我看来是可以一直坚信的一种东西。这其实是我最认可的，当然这是最艰难的。因为这是一个很难和他们有共同语言的东西，跟宗教是完全不同的。我信仰什么呢？首先，我为了突破第一点中的第4点，即我要赋予人生的意义，我认为的人生为什么才有意义呢？我希望是人是永生的，这样我目前做的任何事情，对自己而言都是有意义的，然而客观来讲，肉体是永生的，既然如此，灵魂是否可以？我翻阅过很多典籍，遇到过一些奇人异事，始终在给我导向一个结论：1. 存在鬼神;2. 人是有灵魂的，且可以轮回，也可成神。当然，我只是认可，并非要沉迷于鬼神，这仅仅是我对世界的认知。因此我的信仰是什么呢？ 相信灵魂，敬畏鬼神，以填补人生意义空缺。 需要从内而外地认识自己，并完善自己，使内心安宁，在灵魂层面更有意义。 接受世间的一切，并为之努力奋斗，因为这些对“我”而言，都已经是有意义的事了。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://itnote.tech/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://itnote.tech/tags/随笔/"}],"author":"Shawn Peng"},{"title":"盘口数据深度合并问题","slug":"交易数据深度合并问题","date":"2020-03-08T19:08:00.000Z","updated":"2020-06-26T02:53:51.195Z","comments":true,"path":"2020/03/09/交易数据深度合并问题/","link":"","permalink":"http://itnote.tech/2020/03/09/交易数据深度合并问题/","excerpt":"","text":"问题看到一些股票数据或者数字货币的市场交易深度数据, 不同的价位, 交易的数量不同. 因为买价和卖价精度问题, 这就导致了市场深度可以非常深, 如下图所示: 这是一个火币网数字货币市场交易深度的示例图, 在页面上能看到100个深度, 实际在Rest API请求数据的时候,返回的市场深度可以是150个. 当然, 有些官网也可以返回深度合并的数据. 所以我在遇到这个问题的时候, 走了一点弯路, 实现了这个小的算法问题. 需求对于盘口数据,买单向下合并，卖单向上合并. 同时, 合并的时候就遇到了几个问题需要解决. 合并的精度问题 相同深度订单数量计算 算法我找到了API文档中的ask,bid数据作为样本. 12345678&quot;bids&quot;: [ [3.7721, 344.86],// [price, quote volume] [3.7709, 46.66] ],&quot;asks&quot;: [ [3.7745, 15.44], [3.7746, 70.52]] 在数据样本中, bids是一个二维数组, 第一列是该深度的价格, 第二列是该深度的订单数量.首先解决第一个问题, 如何解决合并深度问题:比如卖单 123456[3.1225, 7],[3.1229, 1],[3.1231, 3],[3.1232, 5],[3.1233, 2],[3.1234, 1] 对于上面的数据, 合并最后一位价格精度, 那深度数据是如何呢? 应该是这样的: 12[3.123, 8],[3.124, 11] 如果合并最后两位呢? 应该如下: 1[3.13, 19] 可以看到算法如下: 1234567891011121314151617181920212223242526272829303132333435363738/** * @param number: 价格 * @param precision： 精度 * @return： 向上合并后的价格 */public float getCeilByLastNumber(float number, int precision) &#123; // 精度小于0，直接返回， 不做精度计算 if (precision &lt; 0) &#123; return number; &#125; // 计算小数点后有几位 int numberLengthAfterPoint = 0; // 临时变量 float tempNum = 0; if (number &gt; 0) &#123; // 这一步的目的是为了方式0.0015这种数， 会出现1.5E-3这种科学计数法 tempNum = number + 1; &#125; else &#123; // 同上 tempNum = number - 1; &#125; // 获取number的字符串表达 String numStr = tempNum + \"\"; // 以小数点分割，第二个数组元素即小数点后的数字 String[] numStrArray = numStr.split(\"\\\\.\"); // 得到小数点后数字的长度 numberLengthAfterPoint = numStrArray[1].length(); if (numberLengthAfterPoint &gt;= precision) &#123; // 向上取数 return getCeilNumberWithPrecision(number, numberLengthAfterPoint - precision + 1); &#125; else &#123; return number; &#125;&#125; public float getCeilNumberWithPrecision(float number, int precision) &#123; return (float) (Math.ceil(number * ((int) Math.pow(10, precision))) / (((int) Math.pow(10, precision)) * 1.0f));&#125; 同理, 对于向下合并也是类似的.","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"用EChart图表进行数据显示","slug":"用EChart图表进行数据显示","date":"2020-02-09T05:22:00.000Z","updated":"2020-06-26T02:50:11.896Z","comments":true,"path":"2020/02/09/用EChart图表进行数据显示/","link":"","permalink":"http://itnote.tech/2020/02/09/用EChart图表进行数据显示/","excerpt":"","text":"问题最近遇到一个问题就是如何在页面上用图表显示数据, 类似大数据可视化平台. 不过在业务需求中不需要显示这么多. 不过有个js组件—“ECharts”, 可以用来可视化数据, 是一个很好的工具.官网: https://www.echartsjs.com/ 需求以下是我需要的一些需求: 需要显示多条曲线 需要显示两个Y轴 区间显示 鼠标悬浮时显示f(x)的值 会在代码里解释, 比较方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 数据准备// data1 和 data2 是预准备的数据,// data1: 成交量, 单位是元// data2: 成交利润, 单位是元var data1 = [ [ \"2014-11-13\", 65 ], [ \"2014-11-14\", 77 ], [ \"2014-11-15\", 143 ] ];var data2 = [ [ \"2014-11-13\", 34 ], [ \"2014-11-14\", 23 ], [ \"2014-11-15\", 55 ] ];option = &#123; tooltip: &#123; //鼠标悬停提示内容 trigger: 'axis', axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: 'cross' // 十字线显示 &#125; &#125;, legend: &#123; y: '20px', data: ['今日成交量', '今日理论利润'], selectedMode: false, &#125;, toolbox: &#123; left: 'center', feature: &#123; dataZoom: &#123; yAxisIndex: 'none' &#125;, dataView: &#123;&#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: [&#123; startValue: '1900-01-01' &#125;, &#123; type: 'inside' &#125;], xAxis: &#123; data: data2.map(function (item) &#123; return item[0]; &#125;), silent: false, splitLine: &#123; show: false &#125; &#125;, yAxis: [ &#123; name: '成交量(元)', nameLocation: 'end', type: 'value' &#125;, &#123; name: '理论利润(元)', nameLocation: 'end', type: 'value' &#125; ], // 两条曲线的数据 series: [&#123; name: '今日成交量', // 平滑曲线 smooth: true, // 显示为line, 也可以是柱形图, 如bar type: 'line', // 显示data1中的数组中, 元素子数组index为1的数据 data: data1.map(function (item) &#123; return item[1]; &#125;) &#125;, &#123; name: '今日理论利润', type: 'line', yAxisIndex: 1, smooth: true, data: data2.map(function (item) &#123; return item[1]; &#125;) &#125;], // 页面上离两边的距离 grid: &#123; left: 50, right: 50 &#125; &#125; 以上是在ECharts官网中的调试代码, 如果真需要在js中呈现, 需要初始化echarts, 示例代码如下: 1234// 获取id为main1的DOM对象引用, 并在该对象上初始化图表var myChart = echarts.init(document.getElementById('main1'));// 图表设置optionmyChart.setOption(option); 为了调试方便, 可以在ECharts官网上先调试图表的渲染是否合适, 随意找一个模版页面, 然后调试,如: https://www.echartsjs.com/examples/zh/editor.html?c=line-aqi 调试页面: 展示按照上面的option设置, 展示如下: 基本实现了功能 总结 图表的展示的调试, 可以在ECharts的官网上调试. 该图表目前只是静态页面, 如果要显示后台数据, 则需要获取后台数据进行展示.","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"图表","slug":"图表","permalink":"http://itnote.tech/tags/图表/"}],"author":"Shawn Peng"},{"title":"URL参数数据转JSON数据","slug":"URL参数数据转JSON数据","date":"2020-01-31T07:47:00.000Z","updated":"2020-06-26T02:54:11.510Z","comments":true,"path":"2020/01/31/URL参数数据转JSON数据/","link":"","permalink":"http://itnote.tech/2020/01/31/URL参数数据转JSON数据/","excerpt":"","text":"问题在调用jQuery.load方法时, 需要将数据Post到controller中, 问题是获取的数据是URL参数形式, 而非是JSON格式, 也没找到现成的解析方法. 当前问题只针对如何将URL参数数据转JSON. 一般是遇不到这种情况, $.ajax和$.post都支持Post JSON数据, 但是业务场景中必须要用到load方法, 于是遇到了这个问题. 原数据: 1&quot;a=avalue&amp;b=bvalue&amp;object%5Bkey1%5D=value1&amp;object%5Bkey2%5D=value2&quot; 目标数据 12345678&#123; &quot;a&quot;:&quot;avalue&quot;, &quot;b&quot;:&quot;bvalue&quot;, &quot;object&quot;:&#123; &quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot; &#125;&#125; 分析为解决这个问题: 将URL参数数据解码 解析数据, 需注意&amp; = [] 字符 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 将URL参数数据解析成Json数据 * * @param originalString: 原始数据 * @return 解析成JSON数据 */public static JSONObject convertURLParamToJsonFormat(String originalString) &#123; JSONObject convertedJsonObject = new JSONObject(); try &#123; // 解码原始数据，以&amp;分割成字符串数组 String[] stringArray = URLDecoder.decode(originalString, \"utf-8\").split(\"&amp;\"); for (String s : stringArray) &#123; // 以=分割成key和value String[] keyAndValue = s.split(\"=\"); // 有[和]是对象，需要特殊处理 if (!keyAndValue[0].contains(\"[\") &amp;&amp; !keyAndValue[0].contains(\"]\")) &#123; // 直接存入为键值对 convertedJsonObject.put(keyAndValue[0], keyAndValue[1]); &#125; else &#123; // 解析为子JSON对象，拿到子对象中的key值 String subKey = getSubUtilSimple(keyAndValue[0], \"\\\\[(.*)\\\\]\", 1); // 拿到key值 String key = getSubUtilSimple(keyAndValue[0], \"(.*)\\\\[\", 1); // 无该key值， 则新建JSON对象 if (convertedJsonObject.get(key) == null) &#123; JSONObject subJsonObject = new JSONObject(); subJsonObject.put(subKey, keyAndValue[1]); convertedJsonObject.put(key, subJsonObject); &#125; else &#123; // 有key值，则取JSON对象 JSONObject subJsonObject = (JSONObject) convertedJsonObject.get(key); subJsonObject.put(subKey, keyAndValue[1]); convertedJsonObject.put(key, subJsonObject); &#125; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // 处理异常 &#125; // 拼装完成，返回结果 return convertedJsonObject;&#125;public static String getSubUtilSimple(String soap, String rgex, int index) &#123; Pattern pattern = Pattern.compile(rgex);// 匹配的模式 Matcher m = pattern.matcher(soap); while (m.find()) &#123; return m.group(index); &#125; return \"\";&#125; 总结这个算法只能解决当前业务场景, 在object中还有子对象, 就有问题. 同时, 如果有数组, 也没法解析. 只能说有局限性, 只能解决一部分问题.","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"删除列表元素重新定位问题","slug":"删除元素重新排序问题","date":"2020-01-31T05:25:00.000Z","updated":"2020-01-31T08:07:17.388Z","comments":true,"path":"2020/01/31/删除元素重新排序问题/","link":"","permalink":"http://itnote.tech/2020/01/31/删除元素重新排序问题/","excerpt":"","text":"问题最近碰到一个小问题, 需要在删除某个元素之后, 页面元素定位到上一个元素. 涉及的问题具体如下. 删除顶层元素, 需要定位到下面的元素.例如删除4,定位到3. 删除中间的元素, 需要定位到上面的元素.删除3, 定位到4. 只有一个元素的时候, 删除并返回空. 分析在问题中已经列举了常见情况和边界情况, 所以需要对边界问题做一些处理. 1234567891011121314151617181920212223242526/** * Reorder page display list * * @param idList: 整个id列表(0,1,2,3,4) * @param locatedId:需要删除的id, 如3. * @return */ private String getNewLocatedId(List&lt;String&gt; idList, String locatedId) &#123; // 列表遍历计数 int count = 0; for (String id : idList) &#123; if (id.equals(locatedId)) &#123; // 找到id并记下是索引号 int index = count; // 特殊情况处理, 遇到尾部元素, 需要取上一个元素 // 常用情况处理, 取下一个元素 index = (index == idList.size() - 1) ? index - 1 : index + 1; // index是-1的情况,必然是只有一个元素并且被删除, 所以返回空字符串. return (index != -1) ? idList.get(index) : \"\"; &#125; count++; &#125; // 找不到，返回空字符串 return \"\";&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"BufferedReader解决中文显示乱码问题","slug":"问题解决-显示中文乱码问题","date":"2020-01-29T07:13:00.000Z","updated":"2020-06-26T02:55:26.758Z","comments":true,"path":"2020/01/29/问题解决-显示中文乱码问题/","link":"","permalink":"http://itnote.tech/2020/01/29/问题解决-显示中文乱码问题/","excerpt":"","text":"问题:在前端显示的时候, 遇到了中文乱码问题.这导致了在UI上无法正常显示中文. 遇到的问题是在通过读取properties文件, 然后根据键值对的value值显示. 例子如下: 修改前的源码如下: 1234567InputStream inputStream = getClass().getResourceAsStream(\"/i18n/\" + name + \".properties\");Properties properties = new Properties();if (inputStream != null) &#123; properties.load(inputStream); model.addAttribute(\"properties\", properties); inputStream.close();&#125; 解决办法:用BufferedReader去读取InputStream, 再load成properties对象. 12345678InputStream inputStream = getClass().getResourceAsStream(\"/i18n/\" + name + \".properties\");Properties properties = new Properties();if (inputStream != null) &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(inputStream)); properties.load(bf); model.addAttribute(\"properties\", properties); inputStream.close();&#125;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"零碎问题","slug":"零碎问题","permalink":"http://itnote.tech/tags/零碎问题/"}],"author":"Shawn Peng"},{"title":"常用正则表达式","slug":"正则表达式常用总结","date":"2020-01-18T12:07:00.000Z","updated":"2020-03-28T13:55:51.162Z","comments":true,"path":"2020/01/18/正则表达式常用总结/","link":"","permalink":"http://itnote.tech/2020/01/18/正则表达式常用总结/","excerpt":"","text":"总结自己常用的正则表达值 找到某个字符之后的字符串：1( -&gt; )(.*) 找到” -&gt; “之后的字符串，例如： 例图 匹配某一个段字符：1&quot;.*?&quot; 找到”中间的字符串。 匹配数字: 1-?[0-9]+.*[0-9]* 判断当前字符串是不是数字: 123public boolean isNumeric(String str) &#123; return str.matches(\"-?[0-9]+.*[0-9]*\");&#125; 匹配空行 1^(\\s*)\\r\\n 匹配不想包含某些字符串的行 1^((?!不想包含的字符串).)*$","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://itnote.tech/categories/问题总结/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://itnote.tech/tags/正则表达式/"}],"author":"Shawn Peng"},{"title":"刷票作弊脚本","slug":"刷票作弊脚本","date":"2019-11-08T04:32:00.000Z","updated":"2019-11-11T01:50:16.738Z","comments":true,"path":"2019/11/08/刷票作弊脚本/","link":"","permalink":"http://itnote.tech/2019/11/08/刷票作弊脚本/","excerpt":"","text":"问题与分析问题最近有个朋友问我能不能帮我写个脚本投投票啊，我看今天有人一下子多了4万的投票，这肯定是作弊啊，你能不能帮帮我？我就很好奇这到底是什么原因。 分析于是我打开他给我的链接一看，非常简单的投票系统，就是发一个个的Get请求就可以了。 我看也挺简单，第一反应就直接写个python脚本去轮询。当然先用Postman做了最简单的测试，手动发了很多Get request，但是不一会儿问题来了。 需要输入验证码，短时间内过高的请求会被目标系统的反爬虫系统识别，IP会被锁定。目前有两个问题需要解决： 如果需要输入验证码，该如何去解析呢？ 为何IP会被封呢？ 针对第一个问题，首先想到的是拿到验证码的图片，然后通过开源软件库将验证码解析出来，经过分析，这个验证码是通过页面点击控件，JS代码触发Get请求生成的，这意味着很难拿到图片，即使可以，那也要通过UI的自动化框架去获取，通过点击控件，然后解析页面元素，很麻烦，而且稳定性不高。 不过既然单个IP会被封，那么通过大量的代理IP去投票是不是就可以了？遇到验证码就换IP，这样是不是就可以规避这个问题了？不错，这是一个很好的解决办法。有了具体的方案之后，开始代码的实施。 实现获取IP资源去网上花了5块钱买了两个IP资源，有效期一天，通过其API接口可以拿到有效的IP和端口号。对于IP资源，不同平台价格、时效、质量不同，网络上也有不少的IP和端口供人使用，经过尝试后都不能用，端口资源被限制。 通过请求暴露的API接口，IP服务商会返回相关的IP信息，下面是返回是带有服务器IP和端口的响应数据： 123456789101112&#123; \"code\":200, \"success\":true, \"data\":[ &#123; \"ip\":\"115.213.103.48\", \"port\":3000, \"during\":2 &#125; ], \"msg\":\"操作成功\"&#125; Coding每次请求，获取IP资源也是新的，所以只要在投票有问题之后，更换IP即可。 只要拿到的结果是成功的，就把IP和端口号解析出来。如果中间出现了什么Exception,那就休息一会，重新更换IP，主要是IP服务商的响应不及时，会有一些错误信息。 1234567891011121314def get_http_server(self, url): res = requests.get(url, timeout=4) res.encoding = 'gb2312' try: rep_dict = json.loads(res.content.decode()) if rep_dict['success'] and rep_dict['code'] == 200: ip = rep_dict['data'][0]['ip'] port = rep_dict['data'][0]['port'] return f\"&#123;ip&#125;:&#123;port&#125;\" return None except: print(\"换IP，休息5秒\") time.sleep(5) 下面的代码中我隐去了API信息，但是不影响逻辑。主要的逻辑是通过代理IP不断地去发送请求，将票数和排名打印出来，如果排名到了第三名，那么投票的票数就够了。 1234567891011121314151617181920212223242526def vote(self, url_get_ip): url = 'vote request url' s = requests.Session() ip_port = self.getHttpServer(url_get_ip) if ip_port: while True: try: time.sleep(2) proxies = &#123; \"http\": \"http://&#123;&#125;\".format(ip_port), \"https\": \"https://&#123;&#125;\".format(ip_port) &#125; res = s.get(url, headers=self.headers, proxies=proxies, timeout=10) res.encoding = 'gb2312' rep_dict = json.loads(res.content.decode()) print(f\"票数:&#123;rep_dict['data']['count']&#125; ===&gt; 排名: &#123;rep_dict['data']['rank']&#125;\") if rep_dict['data']['rank'] == 3: self.not_enough = False break if rep_dict['data']['msg'] == 'need_captcha': print('验证码校验，准备换IP') return False except: print('投票有点小问题，pass') return False else: return False 到目前为止，已经刷到了前5名。这篇文章的目的不是说做什么偏门作弊的东西，只是个人的一种技术尝试，我觉很有意思，就记下来了。 源码仅供学习和参考：https://github.com/SouthernYard/vote","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"事件分发器（订阅/发布模式）的实现","slug":"事件分发器（订阅-发布模式）的实现","date":"2019-11-06T12:17:00.000Z","updated":"2020-06-26T02:57:22.074Z","comments":true,"path":"2019/11/06/事件分发器（订阅-发布模式）的实现/","link":"","permalink":"http://itnote.tech/2019/11/06/事件分发器（订阅-发布模式）的实现/","excerpt":"","text":"最近在写项目的时候需要实现一个事件分发器，事件分发器的职责是订阅和发布消息。因此在这个模式中，订阅者需要订阅自己感兴趣的事件，当事件生成的时候需要将事件发布给订阅者。这种模式的好处在于，订阅者和发布者的低耦合性，发布者不关心订阅者的具体行为，只关心订阅者所订阅的事件。订阅者也不关心发布者如何处理事件，只需要拿到自己想要的事件即可。事件分发器主要有三个部分组成： 订阅者：订阅事件 发布者：发布事件 事件：数据的载体 设计需要有一个数据结构存储所有的订阅者的事件类型，该数据类型中会存储事件类型和订阅者的键值对。 1private Map&lt;EventTypeEnum, LinkedHashMap&lt;Integer, WeakReference&lt;Object&gt;&gt;&gt; events; 当事件发布之后，会根据上面的数据结构将数据分发给各个订阅者。所以还需要一个数据结构存储各种实时产生的事件，由于系统的事件中，对事件顺序要求极高，因此存储的数据结构应该是一个队列。 1private Queue&lt;Event&gt; eventQueue; 事件是由事件源将数据入队，所以需要一个方法将事件放入事件队列中。 123public boolean putEvent(Event event) &#123; return eventQueue.offer(event);&#125; 有了以上的数据结构和方法时候，那么需要订阅者的订阅功能和发布者的发布功能。实际上在这里，事件分发器同时处理了订阅者的订阅，以及将事件发布给订阅者。订阅功能：将订阅者订阅的事件作为键，以及将订阅者的HashCode和实际对象作为值，存储在事件Map容器中。同时也支持取消事件订阅。 123456789101112131415public void subscribe(EventTypeEnum eventType, Object subscriber) &#123; if (!events.containsKey(eventType)) &#123; events.put(eventType, new LinkedHashMap&lt;&gt;()); &#125; // Add events.get(eventType).put(subscriber.hashCode(), new WeakReference&lt;&gt;(subscriber));&#125;public boolean unsubscribe(EventTypeEnum eventType, Object subscriber) &#123; if (events.containsKey(eventType)) &#123; events.get(eventType).remove(subscriber.hashCode()); return true; &#125; return false;&#125; 发布功能：注意到，在事件订阅时，我设计了一个注解，订阅者需要订阅的方法上，需要使用该注解，并说明需要订阅的事件类型。运行时使用，并用在对象方法上。发布事件时，事件分发器会通过反射调用使用该注解的方法，达到发布的效果。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface OnEvent &#123; EventTypeEnum eventType() default EventTypeEnum.EVENT_NONE;&#125; 从事件队列中一一取出事件，通过订阅者订阅方法上的注解及其参数，将匹配的事件发布给订阅者。事件发布事件后，各种订阅者处理时间不太一样，有可能某些订阅的处理是阻塞的。因此我在发布事件的时，设计了异步处理事件对象。对于事件的发布，会有一个线程专门处理事件队列，不断发布事件，并将事件出队，避免事件重复发布。 12345678910111213141516171819202122232425262728293031323334353637 private void publish(Event event) &#123; if (event != null &amp;&amp; events.containsKey(event.getType())) &#123; for (Map.Entry&lt;Integer, WeakReference&lt;Object&gt;&gt; subs : events.get(event.getType()).entrySet()) &#123; WeakReference&lt;Object&gt; subscriberRef = subs.getValue(); Object subscriberObj = subscriberRef.get(); assert subscriberObj != null; for (final Method method : subscriberObj.getClass().getDeclaredMethods()) &#123; OnEvent annotation = method.getAnnotation(OnEvent.class); if (annotation != null &amp;&amp; annotation.eventType().equals(event.getType())) &#123;// 异步处理事件 CompletableFuture.runAsync(() -&gt; deliverEvent(subscriberObj, method, event)); &#125; &#125; &#125; &#125; &#125; private &lt;T&gt; boolean deliverEvent(T subscriber, Method method, Event event) &#123; try &#123; boolean methodFound = false; for (final Class paramClass : method.getParameterTypes()) &#123; if (paramClass.equals(event.getClass())) &#123; methodFound = true; break; &#125; &#125; if (methodFound) &#123; method.setAccessible(true); method.invoke(subscriber, event); &#125; return true; &#125; catch (Exception e) &#123; logger.error(\"Deliver message has failed\", e); &#125; return false; &#125; 对于事件分发器，还有开始运行和结束功能，以及时间事件的发布和订阅，具体可以参考示例代码。 代码及示例 如上图所示，事件分发器在运行之后，会将时间事件自动分发给subscriber。示例代码:https://github.com/SouthernYard/EventDispatcher","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://itnote.tech/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://itnote.tech/tags/设计模式/"}],"author":"Shawn Peng"},{"title":"爬取全国所有手机号码","slug":"爬取上海市的所有电话号码","date":"2019-11-01T12:10:00.000Z","updated":"2019-11-01T15:31:36.164Z","comments":true,"path":"2019/11/01/爬取上海市的所有电话号码/","link":"","permalink":"http://itnote.tech/2019/11/01/爬取上海市的所有电话号码/","excerpt":"","text":"背景之前支付宝可以分享红包，当收到红包的人点开你分享的支付宝口令之后，这个人就会有相应的红包额度。如果这个人在设定的时间内可以用掉这个额度，那你也相应会获得相同的红包数量。当时有人也因此发了笔大财，怎么做的呢？有人会通过群发大量的短信，当很多人收到短信然后会点进支付宝app，然后自己也会有相应的收益。 当然这篇文章的主题不是为了如何赚钱，而是我在思考类似的问题时，想到如何能获取大量的手机号码呢？爬虫一般会遇到信息安全问题，很多涉及个人隐私，所以这里的代码仅供参考。 解决方案 首先我找到了一个网站，手机全能查，按照这里的分类，应该是包含了全中国所有人的手机号码。作为示范，我先尝试爬取的是上海下面的所有手机号码。 根据上面三张图可以看到，三大运营商的上海地区号码都可以在这个链接下面找到. 我随便点击某个号码段，审查网页元素。 可以看到这是一个静态网页，所以解决方案有了： 获取不同号码段 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 将号码存在文件中 OK，下面开始coding。 代码实现对于爬虫来讲，Python是很好的工具，requests和BeautifulSoup都是Python爬虫中很实用的模块。代码也是按前面所述的步骤实现的。 获取不同号码段： 通过这个类去获取所有的号码段： 12345678910111213141516171819202122class GetPhoneSegment(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; self.url = 'http://so.qqdna.com/city/shanghai/shanghai.php' def get_seg_num(self): res = requests.get(self.url) res.encoding = 'gb2312' bs = BeautifulSoup(res.text, 'lxml') all_seg = bs.findAll('li') return self.filter_data(all_seg) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9]+') list_string_data = rr.findall(str(original_data)) data_remove_dup = list(set(list_string_data)) data_remove_dup.sort(key=list_string_data.index) return data_remove_dup 获取号码段的目的是为了拼装不同号码段所对应的URL。 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 通过这个类获取不同的号码段下的所有号码，通过正则表达式解析所有的号码，最后将文件保存到硬盘上。 1234567891011121314151617181920212223class GetPhoneNumber(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; def get_phone_num(self, seg_phone_num): url = 'http://so.qqdna.com/mobile/shanghai_' + seg_phone_num + '.html' res = requests.get(url) res.encoding = 'gb2312' bf = BeautifulSoup(res.text, 'lxml') return str(self.filter_data(bf.body.table.tr.td)) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9][0-9]&#123;9&#125;') list_string_data = str(rr.findall(str(original_data))[2:]) filtered_data = list_string_data.replace(r'[', '') filtered_data = filtered_data.replace(r']', '') filtered_data = filtered_data.replace(r\"', '\", '\\n') filtered_data = filtered_data.replace(r\"'\", '') return filtered_data 将号码存在文件中在下面的主函数中可以看到,将获取到的手机号码存储在txt文本中。1234567891011if __name__ == '__main__': get_phone_seg = GetPhoneSegment() seg_num_list = get_phone_seg.get_seg_num() get_num = GetPhoneNumber() print(\"号码段数量：\" + str(len(seg_num_list))) for seg_num in seg_num_list: data = get_num.get_phone_num(seg_num) fo = open(seg_num + '.txt', 'w') # a: 追加， w: 覆盖 fo.write(data) fo.close() 跑起来!为了验证代码可以正常运行, 直接运行看是否能够下载号码。由于是公司的电脑, 隐去了一些个人信息。 由下图可以看到, 上海市所有的号码段有5880个, 基本上一个号码段是9999个, 按照1万个计算, 上海市的号码数量是5880万个左右, 还是有点多的。 运行中 运行一段时间后, 可以看到文本文件中已经有不少号码了。当然我并没有把将近六千万的号码全部下载完……电脑吃不消,我也不需要这么多。当然为了避免总是在一个号码段下载号码, 可以加入随机函数, 比如说在一个号码段中取10个, 这样也有将近6万个号码，看个人需求。 号码 这个是完整代码：https://github.com/SouthernYard/GetNumber","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"对作弊行为的视频进行数据标注","slug":"对作弊行为的视频进行数据标注","date":"2019-08-26T04:40:00.000Z","updated":"2019-11-01T12:08:20.799Z","comments":true,"path":"2019/08/26/对作弊行为的视频进行数据标注/","link":"","permalink":"http://itnote.tech/2019/08/26/对作弊行为的视频进行数据标注/","excerpt":"","text":"背景最近在参加一个作弊行为分析的比赛，数据集是由比赛方提供的，也是被标注的。对于数据标注，我也进行了一些尝试。 赛题我们最终目标是从真实考场视频录像中检测出谁在什么时候作弊，以及作弊的类型，如看手机，扔纸团等。现阶段我们通过员工录制模拟作弊视频，视频有十段，每段比较类似，都是考场固定30个座位，有二，三十人按照以下顺序作弊：作弊类型：（视频也是根据这个顺序录制的，扔是单人行动，传是两人手与手之间的传动）1.拿出包放到桌上，2.低头拿出手机等偷看3.扔纸团到前桌桌上4.扔纸团给后桌桌上，5.扔纸团给左边桌上6.扔纸团给右边桌上7.传纸条给前桌8.传纸条给后桌9.传纸条给左桌10.传纸条给右桌11.扔纸团到前桌地上12.扔纸团到后桌地上13.扔纸团到左桌地上14.扔纸团到右桌地上15.捡纸团 （捡纸团可能出现在前面行动中，因为可能纸团掉在地上都会去捡）16.打开纸团 （打开纸团前面行动也会有，不管是扔纸团还是传）带试卷出场 数据标注对于视频数据的标注的要求是需要找出各种作弊行为对应的所在帧数。第一行是关注区域四个点坐标，这个区域不能太大，以至于其他同学干扰，不能太小，以至于关注的人动作被剪裁。第二行开始每一个作弊行为一行，每一行起始帧，结束帧，作弊类型。下图就是示例： 数据示例 对于视频数据的标注，就需要用到OpenCV了，初步的想法是： 将指定个某个人的位置框出来 实时显示帧率 不过这也有个小问题，人的动作行为太快，帧率也很快，人工标注是有误差的。尽管如此，我还是对几个样本数据进行了标注，代码实现如下： 12345678910111213141516171819202122import cv2cap = cv2.VideoCapture('./7.mp4')frame_count = 0while cap.isOpened(): ret, frame = cap.read() if ret == True: frame = frame[100:250,950:1100] font = cv2.FONT_HERSHEY_SIMPLEX frame_count = frame_count + 1 cv2.putText(frame, str(frame_count),(0,30), font, 0.5,(255,255,255),2,cv2.LINE_AA) cv2.imshow('frame',frame) c = cv2.waitKey(1) if cv2.waitKey(1) &amp; 0xFF == ord(' '): cv2.waitKey(0) elif c == 27: break else: breakcap.release()cv2.destroyAllWindows() 左上角的白色数据就是帧数，这里的视频就是规定显示的视频区域，由此可以根据要求标注数据。 区域视频","categories":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/categories/数据标注/"}],"tags":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/tags/数据标注/"},{"name":"视频","slug":"视频","permalink":"http://itnote.tech/tags/视频/"},{"name":"机器学习","slug":"机器学习","permalink":"http://itnote.tech/tags/机器学习/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://itnote.tech/tags/OpenCV/"}],"author":"Shawn Peng"},{"title":"[LeetCode]2. 两数相加","slug":"LeetCode-两数相加","date":"2019-08-16T10:11:00.000Z","updated":"2019-08-19T14:05:24.629Z","comments":true,"path":"2019/08/16/LeetCode-两数相加/","link":"","permalink":"http://itnote.tech/2019/08/16/LeetCode-两数相加/","excerpt":"","text":"描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析两数相加，顾名思义这是要解决两个数字相加问题, 而入参是两个链表. 那我们需要思考下面几个问题: 1. 如何按位相加? 观察链表，其第一个节点实际代表的是个位，第二个代表的是十位，依次是百位，千位……所以从第一个节点按位置相加就可以了。 2. 怎么解决进位? 两个0-9的自然数相加的值，最大的和是18，因此，进位只有0或者1，在两数相同位置上加上进位即可，即便加上进位最大也只有19，没到20。因此需要有个变量处理进位问题即可。 3. 链表结束/开始是null, 怎么处理? 对于null值的处理其实很简单，只要认为这是一个值为0的节点即可。如果都是null，那就不用再计算了。 4. 两个链表的长度不一样, 怎么处理? 链表长度不一样意味着是长度不同的数字，那么较短的链表比较长链表短的地方，都认为值为0的节点即可。 5. 进位之后, 两个链表指向的下一个节点是null, 怎么解决? 这算是一个较为边缘的场景，比如[2]+[9], 这个时候高位没有数字，然而进位为1。只要为这个特殊情况再加一个特殊处理即可。 代码步骤： 先定义了计算结果的链表头，链表当前节点和进位变量。 当l1或l2其中之一不为null的时候，进行相加计算。 如果链表（l1,l2）不为null，则取值，反之则取0,因为节点已经用不到，直接移动节点位置。 两个值相加，并加上进位。 计算出进位和当前位的数值。 完成计算，移动计算结果的当前节点。 处理分析章节中的第五个问题，当l1和l2都为null的时候，处理进位问题，有进位，则结果节点再新增一个节点。 返回节点头后面的链表结果，即是题目的解。 两数相加 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //需要一个header和一个pointer ListNode pointer = new ListNode(0), header = pointer; //进位 int carry = 0; //链表其中之一不能为null while((l1 != null || l2 != null)) &#123; //链表为null,返回值就应该为0， 方便相加 int val1 = (l1 != null) ? l1.val : 0; //移动链表节点 if(l1 != null) l1 = l1.next; int val2 = (l2 != null) ? l2.val : 0; if(l2 != null) l2 = l2.next; //上下相加，并且加上进位值 int sum = val1 + val2 + carry; //计算进位，满10进1 carry = sum / 10; //除10的余数就是当前位的值 ListNode currentNode = new ListNode(sum % 10); //结果链表当前节点赋值 pointer.next = currentNode; //移动当前节点 pointer = pointer.next; &#125; if (carry &gt; 0) &#123; // 特殊处理，如果l1与l2都是null的时候：1. l1和l2传进相加方法的时候的时候即是null // 2. 计算到最高位或者，最高位相加满10 pointer.next = new ListNode(carry); &#125; return header.next; &#125;&#125; 拓展 现在的问题是解决两个数相加的问题，那如果是三个数呢？其实从这道题拓展开去也不难，先处理其中两个链表相加的和，在将和的结果和第三个链表相加即可，有点麻烦，也不失为一个办法。 方法传入多参数列表进行处理，此处就不展开了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"如何在云服务器上搭建Hexo博客","slug":"在云服务器上搭建Hexo博客","date":"2019-08-10T08:49:00.000Z","updated":"2020-06-26T02:55:59.631Z","comments":true,"path":"2019/08/10/在云服务器上搭建Hexo博客/","link":"","permalink":"http://itnote.tech/2019/08/10/在云服务器上搭建Hexo博客/","excerpt":"","text":"前言最近搭建一个自己的博客，历时一个星期的空余时间。搭建博客的主要目的是想记录自己的技术笔记和心得，方便与人分享和自己查阅。很久以前我就有搭建博客的想法，但是没有实践，一个是懒，一个是没有找到合适的博客系统。后来发现Hexo这个博客系统，感觉不错，但是看了一些教程，感觉搭建起来很麻烦，我就又放弃了，最近在朋友的鼓励下，终于把想法实践了。 在搭建博客之前，我对比了自己知道两个博客系统，WordPress和Hexo。 WordPress: 优点 缺点 容易搭建，上手快 臃肿不轻便 主题多 需要提供服务器和域名 插件多 Hexo: 优点 缺点 轻便：全是静态文件 只能在本地电脑工作 简洁：天然支持MarkDown 维护不便 免费：GitHub 先前搭建过WordPress, 我并不是很喜欢WordPress的主题风格，个人认为不太适合写技术博客，找了些主题后，没有发现自己喜欢的。看到一些技术大佬很多在用Hexo的博客，并且对比了优缺点，最终决定搭建基于Hexo的博客。根据Hexo的缺点，我萌生了一个想法：能不能将Hexo搭建在云服务上？找了相关资料，确实有人这么做。本片博客主要解决了以下几个问题。 在云服务器上搭建Hexo博客系统 在线编辑和发布博客 配置Https 博客搭建服务器和域名服务器是在阿里云上买的最低配置的香港服务器，因为香港服务器不需要备案就能直接访问，同时速度也不会太差。同时域名也是在阿里云上购买的。 服务器版本CentOS 7.4 Hexo搭建Hexo的搭建过程网上有太多，没必要重复造轮子，没搭建过的朋友可以参考这篇博文。 我的博客用的主题是Indigo,其中不少问题都可以在WiKi中找到。 配置Hexo在搭建完成之后，服务器的运行需要依赖于hexo-server和hexo-admin。如果已经安装，可以跳过此步骤。 cd到博客根目录下，执行： 12npm install hexo-server@0.3.1 --savenpm install hexo-admin@2.3.0 --save 安装完毕之后，执行 1hexo s 打开浏览器，访问http://yourServerIP:4000, 即可预览，访问http://yourServerIP:4000/admin, 即可进入hexo-admin后台管理界面。 hexo-admin默认是没有密码保护，需要自己手动开启。在进入后台管理页面时，点击Settings--Setup authentification here设置后台管理密码。 Setting 输入用户名密码之后，将生成的代码复制。 Admin Config Section 然后打开博客根目录下的_config.yml，将复制的代码粘贴到末尾。重启hexo服务器，进入http://yourServerIP:4000/admin, 如果出现登录界面，则设置成功。 后台运行因为shell关掉或者使用ctrl+c关闭，则会导致服务器结束进程。所以我写了个JS脚本，执行之后，后台会一直运行hexo服务器。安装pm2 1npm install -g pm2 在博客根目录下创建一个hexo_run.js。 123456789const &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 在根目录下运行 1pm2 start hexo_run.js 这样hexo服务器就能一直在后台运行不会被杀死。 Hexo部署每次都用通过指令来部署，那是相当难受的。不过hexo-admin提供了一键部署功能： Deploy 通过点击Deploy按钮就能执行你的部署脚本。在博客根目录下添加配置： 12admin: deployCommand: &apos;./hexo-deploy.sh&apos; 并且在根目录下创建hexo-deploy.sh，并编辑： 12#!/usr/bin/env shhexo g 给hexo-deploy.sh授予权限： 1chmod a+x hexo-deploy.sh 重启服务器之后，编辑博文后点击Deploy按钮就能将文章渲染成html页面访问了。 与Github Page同步GitHub的配置可以参考前文中所提到的博客搭建文章，里面有详细的配置过程。如果需要与Github page同步，则修改hexo-deploy.sh就可以了。修改如下： 12#!/usr/bin/env shhexo g -d 然后重启服务器，点击Deploy按钮即可，之后的改动都会同步到Github上。 服务器配置DNS解析配置进入域名的DNS解析中，按如下配置即可： DNS解析 然后访问你的域名，查看是否能访问到博客页面。 配置Https关于Https的配置，可以参考这篇博文。需要在阿里云购买云盾证书，并添加解析。在下载完证书之后需要在nginx.conf中配置文件。 12345678910111213141516171819202122server &#123; listen 80; server_name www.itnote.tech; return 301 https://www.itnote.tech$request_uri; &#125;server &#123; listen 443 ssl; server_name www.itnote.tech; ssl on; ssl_certificate /usr/local/nginx/cert/pem_file.pem; #证书地址 ssl_certificate_key /usr/local/nginx/cert/key_file.key; #证书地址 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://localhost:4000/; &#125; 保存后重启nginx服务 1service nginx restart 看上图中有锁状的地址即配置成功。 Https Cert","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://itnote.tech/categories/技术分享/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://itnote.tech/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://itnote.tech/tags/Hexo/"},{"name":"Https","slug":"Https","permalink":"http://itnote.tech/tags/Https/"},{"name":"WordPress","slug":"WordPress","permalink":"http://itnote.tech/tags/WordPress/"}],"author":"Shawn Peng"}]}