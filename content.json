{"meta":{"title":"南院大王","subtitle":"十年饮冰，难凉热血。","description":null,"author":"Shawn Peng","url":"http://itnote.tech","root":"/"},"pages":[{"title":"categories","date":"2019-08-06T05:13:19.000Z","updated":"2019-08-06T05:14:11.852Z","comments":false,"path":"categories/index.html","permalink":"http://itnote.tech/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-06T05:12:05.000Z","updated":"2019-08-06T05:13:08.447Z","comments":false,"path":"tags/index.html","permalink":"http://itnote.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"URL参数数据转JSON数据","slug":"URL参数数据转JSON数据","date":"2020-01-31T07:47:00.000Z","updated":"2020-01-31T08:05:06.000Z","comments":true,"path":"2020/01/31/URL参数数据转JSON数据/","link":"","permalink":"http://itnote.tech/2020/01/31/URL参数数据转JSON数据/","excerpt":"","text":"问题在调用jQuery.load方法时, 需要将数据Post到controller中, 问题是获取的数据是URL参数形式, 而非是JSON格式, 也没找到现成的解析方法. 当前问题只针对如何将URL参数数据转JSON. 一般是遇不到这种情况, $.ajax和$.post都支持Post JSON数据, 但是业务场景中必须要用到load方法, 于是遇到了这个问题. 原数据: 1&quot;a=avalue&amp;b=bvalue&amp;object%5Bkey1%5D=value1&amp;object%5Bkey2%5D=value2&quot; 目标数据 12345678&#123; &quot;a&quot;:&quot;avalue&quot;, &quot;b&quot;:&quot;bvalue&quot;, &quot;object&quot;:&#123; &quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot; &#125;&#125; 分析为解决这个问题: 将URL参数数据解码 解析数据, 需注意&amp; = [] 字符 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 将URL参数数据解析成Json数据 * * @param originalString: 原始数据 * @return 解析成JSON数据 */public static JSONObject convertURLParamToJsonFormat(String originalString) &#123; JSONObject convertedJsonObject = new JSONObject(); try &#123; // 解码原始数据，以&amp;分割成字符串数组 String[] stringArray = URLDecoder.decode(originalString, \"utf-8\").split(\"&amp;\"); for (String s : stringArray) &#123; // 以=分割成key和value String[] keyAndValue = s.split(\"=\"); // 有[和]是对象，需要特殊处理 if (!keyAndValue[0].contains(\"[\") &amp;&amp; !keyAndValue[0].contains(\"]\")) &#123; // 直接存入为键值对 convertedJsonObject.put(keyAndValue[0], keyAndValue[1]); &#125; else &#123; // 解析为子JSON对象，拿到子对象中的key值 String subKey = getSubUtilSimple(keyAndValue[0], \"\\\\[(.*)\\\\]\", 1); // 拿到key值 String key = getSubUtilSimple(keyAndValue[0], \"(.*)\\\\[\", 1); // 无该key值， 则新建JSON对象 if (convertedJsonObject.get(key) == null) &#123; JSONObject subJsonObject = new JSONObject(); subJsonObject.put(subKey, keyAndValue[1]); convertedJsonObject.put(key, subJsonObject); &#125; else &#123; // 有key值，则取JSON对象 JSONObject subJsonObject = (JSONObject) convertedJsonObject.get(key); subJsonObject.put(subKey, keyAndValue[1]); convertedJsonObject.put(key, subJsonObject); &#125; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // 处理异常 &#125; // 拼装完成，返回结果 return convertedJsonObject;&#125; 总结这个算法只能解决当前业务场景, 在object中还有子对象, 就有问题. 同时, 如果有数组, 也没法解析. 只能说有局限性, 只能解决一部分问题.","categories":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"删除列表元素重新定位问题","slug":"删除元素重新排序问题","date":"2020-01-31T05:25:00.000Z","updated":"2020-01-31T06:19:29.608Z","comments":true,"path":"2020/01/31/删除元素重新排序问题/","link":"","permalink":"http://itnote.tech/2020/01/31/删除元素重新排序问题/","excerpt":"","text":"问题最近碰到一个小问题, 需要在删除某个元素之后, 页面元素定位到上一个元素. 涉及的问题具体如下. 删除顶层元素, 需要定位到下面的元素.例如删除4,定位到3. 删除中间的元素, 需要定位到上面的元素.删除3, 定位到4. 只有一个元素的时候, 删除并返回空. 分析在问题中已经列举了常见情况和边界情况, 所以需要对边界问题做一些处理. 1234567891011121314151617181920212223242526/** * Reorder page display list * * @param idList: 整个id列表(0,1,2,3,4) * @param locatedId:需要删除的id, 如3. * @return */ private String getNewLocatedId(List&lt;String&gt; idList, String locatedId) &#123; // 列表遍历计数 int count = 0; for (String id : idList) &#123; if (id.equals(locatedId)) &#123; // 找到id并记下是索引号 int index = count; // 特殊情况处理, 遇到尾部元素, 需要取上一个元素 // 常用情况处理, 取下一个元素 index = (index == idList.size() - 1) ? index - 1 : index + 1; // index是-1的情况,必然是只有一个元素并且被删除, 所以返回空字符串. return (index != -1) ? idList.get(index) : \"\"; &#125; count++; &#125; // 找不到，返回空字符串 return \"\";&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"BufferedReader解决中文显示乱码问题","slug":"问题解决-显示中文乱码问题","date":"2020-01-29T07:13:00.000Z","updated":"2020-01-31T05:24:42.371Z","comments":true,"path":"2020/01/29/问题解决-显示中文乱码问题/","link":"","permalink":"http://itnote.tech/2020/01/29/问题解决-显示中文乱码问题/","excerpt":"","text":"问题:在前端显示的时候, 遇到了中文乱码问题.这导致了在UI上无法正常显示中文. 遇到的问题是在通过读取properties文件, 然后根据键值对的value值显示. 例子如下: 修改前的源码如下: 1234567InputStream inputStream = getClass().getResourceAsStream(\"/i18n/\" + name + \".properties\");Properties properties = new Properties();if (inputStream != null) &#123; properties.load(inputStream); model.addAttribute(\"properties\", properties); inputStream.close();&#125; 解决办法:用BufferedReader去读取InputStream, 再load成properties对象. 12345678InputStream inputStream = getClass().getResourceAsStream(\"/i18n/\" + name + \".properties\");Properties properties = new Properties();if (inputStream != null) &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(inputStream)); properties.load(bf); model.addAttribute(\"properties\", properties); inputStream.close();&#125;","categories":[{"name":"零碎问题","slug":"零碎问题","permalink":"http://itnote.tech/categories/零碎问题/"}],"tags":[{"name":"零碎问题","slug":"零碎问题","permalink":"http://itnote.tech/tags/零碎问题/"}],"author":"Shawn Peng"},{"title":"常用正则表达式","slug":"正则表达式常用总结","date":"2020-01-18T12:07:00.000Z","updated":"2020-01-19T15:14:59.975Z","comments":true,"path":"2020/01/18/正则表达式常用总结/","link":"","permalink":"http://itnote.tech/2020/01/18/正则表达式常用总结/","excerpt":"","text":"总结自己常用的正则表达值 找到某个字符之后的字符串：( -&gt; )(.*)找到” -&gt; “之后的字符串，例如： 例图 匹配某一个段字符：”.*?”找到”中间的字符串。","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://itnote.tech/categories/问题总结/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://itnote.tech/tags/正则表达式/"}],"author":"Shawn Peng"},{"title":"刷票作弊脚本","slug":"刷票作弊脚本","date":"2019-11-08T04:32:00.000Z","updated":"2019-11-11T01:50:16.738Z","comments":true,"path":"2019/11/08/刷票作弊脚本/","link":"","permalink":"http://itnote.tech/2019/11/08/刷票作弊脚本/","excerpt":"","text":"问题与分析问题最近有个朋友问我能不能帮我写个脚本投投票啊，我看今天有人一下子多了4万的投票，这肯定是作弊啊，你能不能帮帮我？我就很好奇这到底是什么原因。 分析于是我打开他给我的链接一看，非常简单的投票系统，就是发一个个的Get请求就可以了。 我看也挺简单，第一反应就直接写个python脚本去轮询。当然先用Postman做了最简单的测试，手动发了很多Get request，但是不一会儿问题来了。 需要输入验证码，短时间内过高的请求会被目标系统的反爬虫系统识别，IP会被锁定。目前有两个问题需要解决： 如果需要输入验证码，该如何去解析呢？ 为何IP会被封呢？ 针对第一个问题，首先想到的是拿到验证码的图片，然后通过开源软件库将验证码解析出来，经过分析，这个验证码是通过页面点击控件，JS代码触发Get请求生成的，这意味着很难拿到图片，即使可以，那也要通过UI的自动化框架去获取，通过点击控件，然后解析页面元素，很麻烦，而且稳定性不高。 不过既然单个IP会被封，那么通过大量的代理IP去投票是不是就可以了？遇到验证码就换IP，这样是不是就可以规避这个问题了？不错，这是一个很好的解决办法。有了具体的方案之后，开始代码的实施。 实现获取IP资源去网上花了5块钱买了两个IP资源，有效期一天，通过其API接口可以拿到有效的IP和端口号。对于IP资源，不同平台价格、时效、质量不同，网络上也有不少的IP和端口供人使用，经过尝试后都不能用，端口资源被限制。 通过请求暴露的API接口，IP服务商会返回相关的IP信息，下面是返回是带有服务器IP和端口的响应数据： 123456789101112&#123; \"code\":200, \"success\":true, \"data\":[ &#123; \"ip\":\"115.213.103.48\", \"port\":3000, \"during\":2 &#125; ], \"msg\":\"操作成功\"&#125; Coding每次请求，获取IP资源也是新的，所以只要在投票有问题之后，更换IP即可。 只要拿到的结果是成功的，就把IP和端口号解析出来。如果中间出现了什么Exception,那就休息一会，重新更换IP，主要是IP服务商的响应不及时，会有一些错误信息。 1234567891011121314def get_http_server(self, url): res = requests.get(url, timeout=4) res.encoding = 'gb2312' try: rep_dict = json.loads(res.content.decode()) if rep_dict['success'] and rep_dict['code'] == 200: ip = rep_dict['data'][0]['ip'] port = rep_dict['data'][0]['port'] return f\"&#123;ip&#125;:&#123;port&#125;\" return None except: print(\"换IP，休息5秒\") time.sleep(5) 下面的代码中我隐去了API信息，但是不影响逻辑。主要的逻辑是通过代理IP不断地去发送请求，将票数和排名打印出来，如果排名到了第三名，那么投票的票数就够了。 1234567891011121314151617181920212223242526def vote(self, url_get_ip): url = 'vote request url' s = requests.Session() ip_port = self.getHttpServer(url_get_ip) if ip_port: while True: try: time.sleep(2) proxies = &#123; \"http\": \"http://&#123;&#125;\".format(ip_port), \"https\": \"https://&#123;&#125;\".format(ip_port) &#125; res = s.get(url, headers=self.headers, proxies=proxies, timeout=10) res.encoding = 'gb2312' rep_dict = json.loads(res.content.decode()) print(f\"票数:&#123;rep_dict['data']['count']&#125; ===&gt; 排名: &#123;rep_dict['data']['rank']&#125;\") if rep_dict['data']['rank'] == 3: self.not_enough = False break if rep_dict['data']['msg'] == 'need_captcha': print('验证码校验，准备换IP') return False except: print('投票有点小问题，pass') return False else: return False 到目前为止，已经刷到了前5名。这篇文章的目的不是说做什么偏门作弊的东西，只是个人的一种技术尝试，我觉很有意思，就记下来了。 源码仅供学习和参考：https://github.com/SouthernYard/vote","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"事件分发器（订阅/发布模式）的实现","slug":"事件分发器（订阅-发布模式）的实现","date":"2019-11-06T12:17:00.000Z","updated":"2019-11-19T14:56:13.468Z","comments":true,"path":"2019/11/06/事件分发器（订阅-发布模式）的实现/","link":"","permalink":"http://itnote.tech/2019/11/06/事件分发器（订阅-发布模式）的实现/","excerpt":"","text":"最近在写项目的时候需要实现一个事件分发器，事件分发器的职责是订阅和发布消息。因此在这个模式中，订阅者需要订阅自己感兴趣的事件，当事件生成的时候需要将事件发布给订阅者。这种模式的好处在于，订阅者和发布者的低耦合性，发布者不关心订阅者的具体行为，只关心订阅者所订阅的事件。订阅者也不关心发布者如何处理事件，只需要拿到自己想要的事件即可。事件分发器主要有三个部分组成： 订阅者：订阅事件 发布者：发布事件 事件：数据的载体 设计需要有一个数据结构存储所有的订阅者的事件类型，该数据类型中会存储事件类型和订阅者的键值对。 1private Map&lt;EventTypeEnum, LinkedHashMap&lt;Integer, WeakReference&lt;Object&gt;&gt;&gt; events; 当事件发布之后，会根据上面的数据结构将数据分发给各个订阅者。所以还需要一个数据结构存储各种实时产生的事件，由于系统的事件中，对事件顺序要求极高，因此存储的数据结构应该是一个队列。 1private Queue&lt;Event&gt; eventQueue; 事件是由事件源将数据入队，所以需要一个方法将事件放入事件队列中。 123public boolean putEvent(Event event) &#123; return eventQueue.offer(event);&#125; 有了以上的数据结构和方法时候，那么需要订阅者的订阅功能和发布者的发布功能。实际上在这里，事件分发器同时处理了订阅者的订阅，以及将事件发布给订阅者。订阅功能：将订阅者订阅的事件作为键，以及将订阅者的HashCode和实际对象作为值，存储在事件Map容器中。同时也支持取消事件订阅。 123456789101112131415public void subscribe(EventTypeEnum eventType, Object subscriber) &#123; if (!events.containsKey(eventType)) &#123; events.put(eventType, new LinkedHashMap&lt;&gt;()); &#125; // Add events.get(eventType).put(subscriber.hashCode(), new WeakReference&lt;&gt;(subscriber));&#125;public boolean unsubscribe(EventTypeEnum eventType, Object subscriber) &#123; if (events.containsKey(eventType)) &#123; events.get(eventType).remove(subscriber.hashCode()); return true; &#125; return false;&#125; 发布功能：注意到，在事件订阅时，我设计了一个注解，订阅者需要订阅的方法上，需要使用该注解，并说明需要订阅的事件类型。运行时使用，并用在对象方法上。发布事件时，事件分发器会通过反射调用使用该注解的方法，达到发布的效果。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface OnEvent &#123; EventTypeEnum eventType() default EventTypeEnum.EVENT_NONE;&#125; 从事件队列中一一取出事件，通过订阅者订阅方法上的注解及其参数，将匹配的事件发布给订阅者。事件发布事件后，各种订阅者处理时间不太一样，有可能某些订阅的处理是阻塞的。因此我在发布事件的时，设计了异步处理事件对象。对于事件的发布，会有一个线程专门处理事件队列，不断发布事件，并将事件出队，避免事件重复发布。 12345678910111213141516171819202122232425262728293031323334353637 private void publish(Event event) &#123; if (event != null &amp;&amp; events.containsKey(event.getType())) &#123; for (Map.Entry&lt;Integer, WeakReference&lt;Object&gt;&gt; subs : events.get(event.getType()).entrySet()) &#123; WeakReference&lt;Object&gt; subscriberRef = subs.getValue(); Object subscriberObj = subscriberRef.get(); assert subscriberObj != null; for (final Method method : subscriberObj.getClass().getDeclaredMethods()) &#123; OnEvent annotation = method.getAnnotation(OnEvent.class); if (annotation != null &amp;&amp; annotation.eventType().equals(event.getType())) &#123;// 异步处理事件 CompletableFuture.runAsync(() -&gt; deliverEvent(subscriberObj, method, event)); &#125; &#125; &#125; &#125; &#125; private &lt;T&gt; boolean deliverEvent(T subscriber, Method method, Event event) &#123; try &#123; boolean methodFound = false; for (final Class paramClass : method.getParameterTypes()) &#123; if (paramClass.equals(event.getClass())) &#123; methodFound = true; break; &#125; &#125; if (methodFound) &#123; method.setAccessible(true); method.invoke(subscriber, event); &#125; return true; &#125; catch (Exception e) &#123; logger.error(\"Deliver message has failed\", e); &#125; return false; &#125; 对于事件分发器，还有开始运行和结束功能，以及时间事件的发布和订阅，具体可以参考示例代码。 代码及示例 如上图所示，事件分发器在运行之后，会将时间事件自动分发给subscriber。示例代码:https://github.com/SouthernYard/EventDispatcher","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://itnote.tech/categories/设计模式/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://itnote.tech/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://itnote.tech/tags/设计模式/"}],"author":"Shawn Peng"},{"title":"爬取全国所有手机号码","slug":"爬取上海市的所有电话号码","date":"2019-11-01T12:10:00.000Z","updated":"2019-11-01T15:31:36.164Z","comments":true,"path":"2019/11/01/爬取上海市的所有电话号码/","link":"","permalink":"http://itnote.tech/2019/11/01/爬取上海市的所有电话号码/","excerpt":"","text":"背景之前支付宝可以分享红包，当收到红包的人点开你分享的支付宝口令之后，这个人就会有相应的红包额度。如果这个人在设定的时间内可以用掉这个额度，那你也相应会获得相同的红包数量。当时有人也因此发了笔大财，怎么做的呢？有人会通过群发大量的短信，当很多人收到短信然后会点进支付宝app，然后自己也会有相应的收益。 当然这篇文章的主题不是为了如何赚钱，而是我在思考类似的问题时，想到如何能获取大量的手机号码呢？爬虫一般会遇到信息安全问题，很多涉及个人隐私，所以这里的代码仅供参考。 解决方案 首先我找到了一个网站，手机全能查，按照这里的分类，应该是包含了全中国所有人的手机号码。作为示范，我先尝试爬取的是上海下面的所有手机号码。 根据上面三张图可以看到，三大运营商的上海地区号码都可以在这个链接下面找到. 我随便点击某个号码段，审查网页元素。 可以看到这是一个静态网页，所以解决方案有了： 获取不同号码段 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 将号码存在文件中 OK，下面开始coding。 代码实现对于爬虫来讲，Python是很好的工具，requests和BeautifulSoup都是Python爬虫中很实用的模块。代码也是按前面所述的步骤实现的。 获取不同号码段： 通过这个类去获取所有的号码段： 12345678910111213141516171819202122class GetPhoneSegment(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; self.url = 'http://so.qqdna.com/city/shanghai/shanghai.php' def get_seg_num(self): res = requests.get(self.url) res.encoding = 'gb2312' bs = BeautifulSoup(res.text, 'lxml') all_seg = bs.findAll('li') return self.filter_data(all_seg) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9]+') list_string_data = rr.findall(str(original_data)) data_remove_dup = list(set(list_string_data)) data_remove_dup.sort(key=list_string_data.index) return data_remove_dup 获取号码段的目的是为了拼装不同号码段所对应的URL。 在不同号码段下，请求页面，并通过正则表达式将号码解析出来 通过这个类获取不同的号码段下的所有号码，通过正则表达式解析所有的号码，最后将文件保存到硬盘上。 1234567891011121314151617181920212223class GetPhoneNumber(object): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/66.0.3359.117 Safari/537.36' &#125; def get_phone_num(self, seg_phone_num): url = 'http://so.qqdna.com/mobile/shanghai_' + seg_phone_num + '.html' res = requests.get(url) res.encoding = 'gb2312' bf = BeautifulSoup(res.text, 'lxml') return str(self.filter_data(bf.body.table.tr.td)) @staticmethod def filter_data(original_data): rr = re.compile(r'[1][0-9][0-9]&#123;9&#125;') list_string_data = str(rr.findall(str(original_data))[2:]) filtered_data = list_string_data.replace(r'[', '') filtered_data = filtered_data.replace(r']', '') filtered_data = filtered_data.replace(r\"', '\", '\\n') filtered_data = filtered_data.replace(r\"'\", '') return filtered_data 将号码存在文件中在下面的主函数中可以看到,将获取到的手机号码存储在txt文本中。1234567891011if __name__ == '__main__': get_phone_seg = GetPhoneSegment() seg_num_list = get_phone_seg.get_seg_num() get_num = GetPhoneNumber() print(\"号码段数量：\" + str(len(seg_num_list))) for seg_num in seg_num_list: data = get_num.get_phone_num(seg_num) fo = open(seg_num + '.txt', 'w') # a: 追加， w: 覆盖 fo.write(data) fo.close() 跑起来!为了验证代码可以正常运行, 直接运行看是否能够下载号码。由于是公司的电脑, 隐去了一些个人信息。 由下图可以看到, 上海市所有的号码段有5880个, 基本上一个号码段是9999个, 按照1万个计算, 上海市的号码数量是5880万个左右, 还是有点多的。 运行中 运行一段时间后, 可以看到文本文件中已经有不少号码了。当然我并没有把将近六千万的号码全部下载完……电脑吃不消,我也不需要这么多。当然为了避免总是在一个号码段下载号码, 可以加入随机函数, 比如说在一个号码段中取10个, 这样也有将近6万个号码，看个人需求。 号码 这个是完整代码：https://github.com/SouthernYard/GetNumber","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://itnote.tech/tags/爬虫/"}],"author":"Shawn Peng"},{"title":"对作弊行为的视频进行数据标注","slug":"对作弊行为的视频进行数据标注","date":"2019-08-26T04:40:00.000Z","updated":"2019-11-01T12:08:20.799Z","comments":true,"path":"2019/08/26/对作弊行为的视频进行数据标注/","link":"","permalink":"http://itnote.tech/2019/08/26/对作弊行为的视频进行数据标注/","excerpt":"","text":"背景最近在参加一个作弊行为分析的比赛，数据集是由比赛方提供的，也是被标注的。对于数据标注，我也进行了一些尝试。 赛题我们最终目标是从真实考场视频录像中检测出谁在什么时候作弊，以及作弊的类型，如看手机，扔纸团等。现阶段我们通过员工录制模拟作弊视频，视频有十段，每段比较类似，都是考场固定30个座位，有二，三十人按照以下顺序作弊：作弊类型：（视频也是根据这个顺序录制的，扔是单人行动，传是两人手与手之间的传动）1.拿出包放到桌上，2.低头拿出手机等偷看3.扔纸团到前桌桌上4.扔纸团给后桌桌上，5.扔纸团给左边桌上6.扔纸团给右边桌上7.传纸条给前桌8.传纸条给后桌9.传纸条给左桌10.传纸条给右桌11.扔纸团到前桌地上12.扔纸团到后桌地上13.扔纸团到左桌地上14.扔纸团到右桌地上15.捡纸团 （捡纸团可能出现在前面行动中，因为可能纸团掉在地上都会去捡）16.打开纸团 （打开纸团前面行动也会有，不管是扔纸团还是传）带试卷出场 数据标注对于视频数据的标注的要求是需要找出各种作弊行为对应的所在帧数。第一行是关注区域四个点坐标，这个区域不能太大，以至于其他同学干扰，不能太小，以至于关注的人动作被剪裁。第二行开始每一个作弊行为一行，每一行起始帧，结束帧，作弊类型。下图就是示例： 数据示例 对于视频数据的标注，就需要用到OpenCV了，初步的想法是： 将指定个某个人的位置框出来 实时显示帧率 不过这也有个小问题，人的动作行为太快，帧率也很快，人工标注是有误差的。尽管如此，我还是对几个样本数据进行了标注，代码实现如下： 12345678910111213141516171819202122import cv2cap = cv2.VideoCapture('./7.mp4')frame_count = 0while cap.isOpened(): ret, frame = cap.read() if ret == True: frame = frame[100:250,950:1100] font = cv2.FONT_HERSHEY_SIMPLEX frame_count = frame_count + 1 cv2.putText(frame, str(frame_count),(0,30), font, 0.5,(255,255,255),2,cv2.LINE_AA) cv2.imshow('frame',frame) c = cv2.waitKey(1) if cv2.waitKey(1) &amp; 0xFF == ord(' '): cv2.waitKey(0) elif c == 27: break else: breakcap.release()cv2.destroyAllWindows() 左上角的白色数据就是帧数，这里的视频就是规定显示的视频区域，由此可以根据要求标注数据。 区域视频","categories":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/categories/数据标注/"}],"tags":[{"name":"数据标注","slug":"数据标注","permalink":"http://itnote.tech/tags/数据标注/"},{"name":"视频","slug":"视频","permalink":"http://itnote.tech/tags/视频/"},{"name":"机器学习","slug":"机器学习","permalink":"http://itnote.tech/tags/机器学习/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://itnote.tech/tags/OpenCV/"}],"author":"Shawn Peng"},{"title":"[LeetCode]2. 两数相加","slug":"LeetCode-两数相加","date":"2019-08-16T10:11:00.000Z","updated":"2019-08-19T14:05:24.629Z","comments":true,"path":"2019/08/16/LeetCode-两数相加/","link":"","permalink":"http://itnote.tech/2019/08/16/LeetCode-两数相加/","excerpt":"","text":"描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析两数相加，顾名思义这是要解决两个数字相加问题, 而入参是两个链表. 那我们需要思考下面几个问题: 1. 如何按位相加? 观察链表，其第一个节点实际代表的是个位，第二个代表的是十位，依次是百位，千位……所以从第一个节点按位置相加就可以了。 2. 怎么解决进位? 两个0-9的自然数相加的值，最大的和是18，因此，进位只有0或者1，在两数相同位置上加上进位即可，即便加上进位最大也只有19，没到20。因此需要有个变量处理进位问题即可。 3. 链表结束/开始是null, 怎么处理? 对于null值的处理其实很简单，只要认为这是一个值为0的节点即可。如果都是null，那就不用再计算了。 4. 两个链表的长度不一样, 怎么处理? 链表长度不一样意味着是长度不同的数字，那么较短的链表比较长链表短的地方，都认为值为0的节点即可。 5. 进位之后, 两个链表指向的下一个节点是null, 怎么解决? 这算是一个较为边缘的场景，比如[2]+[9], 这个时候高位没有数字，然而进位为1。只要为这个特殊情况再加一个特殊处理即可。 代码步骤： 先定义了计算结果的链表头，链表当前节点和进位变量。 当l1或l2其中之一不为null的时候，进行相加计算。 如果链表（l1,l2）不为null，则取值，反之则取0,因为节点已经用不到，直接移动节点位置。 两个值相加，并加上进位。 计算出进位和当前位的数值。 完成计算，移动计算结果的当前节点。 处理分析章节中的第五个问题，当l1和l2都为null的时候，处理进位问题，有进位，则结果节点再新增一个节点。 返回节点头后面的链表结果，即是题目的解。 两数相加 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //需要一个header和一个pointer ListNode pointer = new ListNode(0), header = pointer; //进位 int carry = 0; //链表其中之一不能为null while((l1 != null || l2 != null)) &#123; //链表为null,返回值就应该为0， 方便相加 int val1 = (l1 != null) ? l1.val : 0; //移动链表节点 if(l1 != null) l1 = l1.next; int val2 = (l2 != null) ? l2.val : 0; if(l2 != null) l2 = l2.next; //上下相加，并且加上进位值 int sum = val1 + val2 + carry; //计算进位，满10进1 carry = sum / 10; //除10的余数就是当前位的值 ListNode currentNode = new ListNode(sum % 10); //结果链表当前节点赋值 pointer.next = currentNode; //移动当前节点 pointer = pointer.next; &#125; if (carry &gt; 0) &#123; // 特殊处理，如果l1与l2都是null的时候：1. l1和l2传进相加方法的时候的时候即是null // 2. 计算到最高位或者，最高位相加满10 pointer.next = new ListNode(carry); &#125; return header.next; &#125;&#125; 拓展 现在的问题是解决两个数相加的问题，那如果是三个数呢？其实从这道题拓展开去也不难，先处理其中两个链表相加的和，在将和的结果和第三个链表相加即可，有点麻烦，也不失为一个办法。 方法传入多参数列表进行处理，此处就不展开了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://itnote.tech/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://itnote.tech/tags/算法/"}],"author":"Shawn Peng"},{"title":"如何在云服务器上搭建Hexo博客","slug":"在云服务器上搭建Hexo博客","date":"2019-08-10T08:49:00.000Z","updated":"2019-08-16T12:56:49.863Z","comments":true,"path":"2019/08/10/在云服务器上搭建Hexo博客/","link":"","permalink":"http://itnote.tech/2019/08/10/在云服务器上搭建Hexo博客/","excerpt":"","text":"前言最近搭建一个自己的博客，历时一个星期的空余时间。搭建博客的主要目的是想记录自己的技术笔记和心得，方便与人分享和自己查阅。很久以前我就有搭建博客的想法，但是没有实践，一个是懒，一个是没有找到合适的博客系统。后来发现Hexo这个博客系统，感觉不错，但是看了一些教程，感觉搭建起来很麻烦，我就又放弃了，最近在朋友的鼓励下，终于把想法实践了。 在搭建博客之前，我对比了自己知道两个博客系统，WordPress和Hexo。 WordPress: 优点 缺点 容易搭建，上手快 臃肿不轻便 主题多 需要提供服务器和域名 插件多 Hexo: 优点 缺点 轻便：全是静态文件 只能在本地电脑工作 简洁：天然支持MarkDown 维护不便 免费：GitHub 先前搭建过WordPress, 我并不是很喜欢WordPress的主题风格，个人认为不太适合写技术博客，找了些主题后，没有发现自己喜欢的。看到一些技术大佬很多在用Hexo的博客，并且对比了优缺点，最终决定搭建基于Hexo的博客。根据Hexo的缺点，我萌生了一个想法：能不能将Hexo搭建在云服务上？找了相关资料，确实有人这么做。本片博客主要解决了以下几个问题。 在云服务器上搭建Hexo博客系统 在线编辑和发布博客 配置Https 博客搭建服务器和域名服务器是在阿里云上买的最低配置的香港服务器，因为香港服务器不需要备案就能直接访问，同时速度也不会太差。同时域名也是在阿里云上购买的。 服务器版本CentOS 7.4 Hexo搭建Hexo的搭建过程网上有太多，没必要重复造轮子，没搭建过的朋友可以参考这篇博文。 我的博客用的主题是Indigo,其中不少问题都可以在WiKi中找到。 配置Hexo在搭建完成之后，服务器的运行需要依赖于hexo-server和hexo-admin。如果已经安装，可以跳过此步骤。 cd到博客根目录下，执行： 12npm install hexo-server@0.3.1 --savenpm install hexo-admin@2.3.0 --save 安装完毕之后，执行 1hexo s 打开浏览器，访问http://yourServerIP:4000, 即可预览，访问http://yourServerIP:4000/admin, 即可进入hexo-admin后台管理界面。 hexo-admin默认是没有密码保护，需要自己手动开启。在进入后台管理页面时，点击Settings--Setup authentification here设置后台管理密码。 Setting 输入用户名密码之后，将生成的代码复制。 Admin Config Section 然后打开博客根目录下的_config.yml，将复制的代码粘贴到末尾。重启hexo服务器，进入http://yourServerIP:4000/admin, 如果出现登录界面，则设置成功。 后台运行因为shell关掉或者使用ctrl+c关闭，则会导致服务器结束进程。所以我写了个JS脚本，执行之后，后台会一直运行hexo服务器。安装pm2 1npm install -g pm2 在博客根目录下创建一个hexo_run.js。 123456789const &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log('exec error: $&#123;error&#125;') return &#125; console.log('stdout: $&#123;stdout&#125;'); console.log('stderr: $&#123;stderr&#125;');&#125;) 在根目录下运行 1pm2 start hexo_run.js 这样hexo服务器就能一直在后台运行不会被杀死。 Hexo部署每次都用通过指令来部署，那是相当难受的。不过hexo-admin提供了一键部署功能： Deploy 通过点击Deploy按钮就能执行你的部署脚本。在博客根目录下添加配置： 12admin: deployCommand: &apos;./hexo-deploy.sh&apos; 并且在根目录下创建hexo-deploy.sh，并编辑： 12#!/usr/bin/env shhexo g 给hexo-deploy.sh授予权限： 1chmod a+x hexo-deploy.sh 重启服务器之后，编辑博文后点击Deploy按钮就能将文章渲染成html页面访问了。 与Github Page同步GitHub的配置可以参考前文中所提到的博客搭建文章，里面有详细的配置过程。如果需要与Github page同步，则修改hexo-deploy.sh就可以了。修改如下： 12#!/usr/bin/env shhexo g -d 然后重启服务器，点击Deploy按钮即可，之后的改动都会同步到Github上。 服务器配置DNS解析配置进入域名的DNS解析中，按如下配置即可： DNS解析 然后访问你的域名，查看是否能访问到博客页面。 配置Https关于Https的配置，可以参考这篇博文。需要在阿里云购买云盾证书，并添加解析。在下载完证书之后需要在nginx.conf中配置文件。 12345678910111213141516171819202122server &#123; listen 80; server_name www.itnote.tech; return 301 https://www.itnote.tech$request_uri; &#125;server &#123; listen 443 ssl; server_name www.itnote.tech; ssl on; ssl_certificate /usr/local/nginx/cert/pem_file.pem; #证书地址 ssl_certificate_key /usr/local/nginx/cert/key_file.key; #证书地址 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://localhost:4000/; &#125; 保存后重启nginx服务 1service nginx restart 看上图中有锁状的地址即配置成功。 Https Cert","categories":[{"name":"博客","slug":"博客","permalink":"http://itnote.tech/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://itnote.tech/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://itnote.tech/tags/Hexo/"},{"name":"Https","slug":"Https","permalink":"http://itnote.tech/tags/Https/"},{"name":"WordPress","slug":"WordPress","permalink":"http://itnote.tech/tags/WordPress/"}],"author":"Shawn Peng"}]}